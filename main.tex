\documentclass{article}
\input{preamble}

\title{Nitro Protocol}
\author{Tom Close}

\begin{document}

\maketitle
\begin{abstract}
  State channels are an important technique for scaling blockchains, allowing a fixed set of participants to trustlessly execute a series of state transitions off-chain, in order to determine how a set of assets should be distributed between them.
  In this paper we present constructions that allow state channels to be fund\todo{`to fund' or `to be funded by'} one another, significantly reducing the number of on-chain deposits required.
  Unlike in previous constructions, channels funded by parent channels operate identically to channels funded on-chain, making it easier to reason about the applications that run within them.
  We develop the logic to prove the correctness of our constructions.
\end{abstract}

\section{Motivation}

State channels are an important technique for scaling blockchains.
In a state channel, a fixed set of participants execute a series of state transitions off-chain, in order to determine how a set of assets should be distributed between them.
By allowing participants to execute these transitions off-chain, the state channel removes load from the blockchain, allowing it to support the same level of activity with fewer transactions.


- state channels allow state updates \todo{complete this thought}
Unlike many other scaling techniques, state channels provide a way to run arbitrary state update protocols, instead of just providing a method for realizing transfers off-chain.

Beyond scaling, state channels bring instant finality to blockchain transactions:
value can be considered to be transferred at the moment when a state channel update is received.
The holder of a fully signed state does not need to wait for the transaction to be mined, safe in the knowledge
that they have the right to claim the assets on-chain at a future point of time of their choosing.

In their naive form, each state channel needs to have a corresponding \textit{state deposit} - a set of assets held in escrow on-chain, to be distributed according to the outcome of the channel.
Each time a state channel is opened at least one party needs to perform an on-chain transaction to transfer assets into the state deposit, and each time it is closed at least one participant must perform an on-chain transaction to claim their share.
This limits the effectiveness of state channels as a scaling solution, making it only suitable for the case where a large number of transactions are executed between a single group of participants.
We refer to these naive channels as \textbf{direct channels}, as they are supported directly by funds held on the blockchain.

\subsection{Ledger Channels and Virtual Channels}

Ledger channels allow multiple channels between a given set of participants to be supported by a single on-chain deposit.
Importantly, these channels still update independently to one another, even though they are funded by the same deposit.

As an example of what ledger channels enable, suppose Alice and Bob want to play a game of chess and that
they already have an existing ledger channel, $L$, open between them.
The winner of the game of chess should receive 2 coins from the loser and $L$ currently holds
5 of Alice's coins and 5 of Bob's.

\begin{center}
  \includegraphics[scale=0.5]{turbo_start} % TODO: tikz
\end{center}

Alice and Bob proceed by preparing a new channel for the chess game with the appropriate starting state.
Ordinarily, the chess game would now require an on-chain transaction.
Instead, Alice and Bob then update the ledger channel to allocate funds to these games.

\begin{center}
  \includegraphics[scale=0.5]{turbo_open} %TODO: tikz
\end{center}

Once the funds are allocated, they are free to play the game of chess.
Updates to the chess channel are independent from updates to the ledger channel $L$ and to
any other sub-channels that are potentially funded by it. 
Alice wins the chess game, so the final state in the chess channel allocates all the
funds to her.

\begin{center}
  \includegraphics[scale=0.5]{turbo_close} %TODO: tikz
\end{center}

To close the chess channel off-chain, Alice and Bob update the state of the ledger channel to absorb the outcome of the game.

\begin{center}
  \includegraphics[scale=0.5]{turbo_finish} %TODO: tikz
\end{center}

Virtual channels go one step further than ledger channels, allowing a state channel to be opened between two participants who do not share an on-chain deposit, but instead have a counterparty in common, with whom they both have a channel open with.

As an example, suppose that Alice wants to open an $\{A:5, B:5\}$ chess game with Bob, but they do not share an existing ledger channel.\todo{there are two problems here: 1. the outcome notation here doesn't match the notation used later, and 2. the notation for an outcome isn't ever defined}
Alice does, however, have an $\{A:5, C:5\}$ ledger channel open with Ingrid and Bob and Ingrid have a $\{B:5, C:5\}$ ledger channel open too.

By using a virtual channel, Alice and Bob may open their chess game, using their existing ledger channels with Ingrid, without the need for any on-chain transactions.
Suppose that Alice wins all of the funds in the channel, so that the final outcome is $\{A: 10, B: 0\}$.
Alice and Bob can also close their chess game off-chain, rebalancing through Ingrid, so that the final state of the ledger channels is $\{A: 10, C: 0\}$ and $\{B: 0, C: 10\}$.

In this interaction, Ingrid contributed 10 of her coins at the beginning, which had to remain locked while Alice and Bob were playing.
At the end of the interaction, Ingrid still had 10 coins but they were distributed differently between the her ledger channels.
By locking up her coins for a period of time, she enabled Alice and Bob to play chess entirely off-chain, including the setup and conclusion phases.
Although all this occured off-chain, Alice and Bob received security assurances similar to if the entire interaction had been on-chain.

One good way of summarising the differences between these three different approaches is to look at the number of on-chain deposits required in each of them:
\begin{itemize}
  \item \textbf{Direct channels}: one state deposit per channel.
  \item \textbf{Ledger channels}: one state deposit per group of interacting participants, regardless of how many channels they participate in together.
  \item \textbf{Virtual channels}: one state deposit per user, regardless on how many channels they participate in.
\end{itemize}
Virtual channels hold the biggest potential in terms of scaling, requiring only one on-chain deposit per participant.

\section{Existing work}

- lightning network
- raiden
- in production, payments only

- celer network proposes using 

- counterfactual using counterfactual instantiation
- high level overview about how to implement meta channels details are not presented in the paper

- perun virtual channels



\subsection{Our contribution}

- virtual and ledger channels
- channels are unrestricted
- no time limits or special update rules due to being in a virtual channel

We will now proceed with a more technical exposition of our protocol, which achieves the functionality outlined above.

\section{State Channel Background}

In this section, we introduce the state channel concepts necessary to understand the rest of the paper.

\subsection{Operating vs. Funding State Channels}

At the heart of our approach lies the decision to make the funding of a state channel independent from its operation.

We view a state channel as a device for allowing a fixed set of participants to determine how a set of shared assets should be apportioned between them.
We refer to the set of instructions that determine how the funds should be apportioned as the  \textbf{outcome} the state channel.
We define the \textbf{operation} of a state channel to be the process by which the channel reaches an outcome. 
The \textbf{funding} of a state channel is the method of ensuring that the assets exist and that they will ultimately be distributed according to the channel's outcome.

\begin{table}[]
  \begin{tabular}{|l|l|l|}
  \hline
  \textbf{Operation} & \textbf{Funding} \\ \hline
  States &        Deposits \\ 
  Transitions &   Withdrawals \\ 
  Challenges &     \\ 
  Responses &    \\ \hline
  \end{tabular}
  \end{table}

Specifying the operation of a state channel involves specifying the format of the states and the update rules that define the allowed transitions between these states.
The operation specification also defines the rules surrounding on-chain challenges and the various ways to respond to them.
The ForceMove protocol is an example of a protocol that specifies the operation of a state channel.
In this paper, we will not specify the operation of state channels, but will use ForceMove as an example where required.

Specifying how state channels are funded involves specifying how funds are held in escrow on the chain, how they can be deposited and how they can be claimed according to the outcome of a state channel.
As we will see in this paper, it can also involve specifying the rules for how the outcomes of multiple channels interact, which enables channels to be funded and defunded without on-chain operations.
In the ForceMove paper, all funding is performed by the \textit{SimpleAdjudicator}, which only allows for direct channels between participants.\todo{
  Perhaps it's better to say that in the ForceMove paper, a SimpleAdjudicator is specified, which only allows a single direct channel between two participants.
  (My point is that the ForceMove paper is about the specification of the operation of a state channel, and not really the funding of it.)
}

Decoupling the funding of a channel from its operation has several advantages.
Provided that the channel is funded, its operation is completely independent from the other channels in the network.
The source of funding for a channel can even change from off-chain to on-chain, all without interrupting the operation of that channel.
Overall, by forcing channels to operate independently and to only be coupled through funding relationships, it becomes far easier to reason about the behaviour of any applications running within a state channel.


\subsection{Addresses and Coins}

A state channel is a protocol followed by a set of \textbf{participants}, each defined by a unique cryptographic address.
The private keys corresponding to these addresses are used to sign updates to the channel.
We assume that the signature scheme is unforgeable, so that only the owner of the address has the capability to sign states as that participant.

Each channel has a \textbf{channel address} which is formed by taking the hash of the participant addresses along with a nonce, $k$, that is chosen by the participants in order to distinguish their channels from one another.
We assume that the hashing algorithm is cryptographically secure, so that it impossible for two different sets of participants to create a channel with the same address.\todo{``it possible for any participant to force a distinct channel address, by using a unique nonce''}
We also assume that the signature scheme and hashing algorithm together make it impossible to create a channel address that is the same as a participant address:
we call this the `no collision' assumption.
In practice, we accept that these statements will not be absolute but instead will hold with high probability.

A state channel ultimately determines the quantity of a given asset that each participant should receive.
The format that the asset quantity takes is an important consideration for a state channel.
Blockchains typically have a max integer size, $M$, meaning that a state channel on a single asset
has asset quantites in $\mathbb{Z}_M$, so that quantities above $M$ overflow.
Similarly the quantities for a state channel on two assets takes values in $\mathbb{Z}_M \times \mathbb{Z}_M$.
There are many other possibilities here, including having state channels governing an arbitrary set of assets.
In this paper, we will simplify the explanation by only considering state channels on a single
asset, taking quantity values in $\mathbb{Z}^+$, thereby explicitly ignoring integer overflow issues.
We will refer to this asset as `coins'.

\subsection{Depositing, Holding and Withdrawing}

In order to store value, a state channel network must be backed by assets held on-chain.
In our explanation, we assume that these funds are held and managed by a single smart contract,
which we will refer to as the \textbf{adjudicator}.
In practice, the adjudicator functionality could be split across multiple smart contracts.

We say that $\rchi$ \textbf{holds} $x$, in the case where there is a quantity of $x$ coins
locked on-chain against $\rchi$'s address.
We write this statement $\adj{\holds{\rchi}{x}{}}$,
where the double brackets $\adj{\;}$ indicate that the statement refers to state on the chain.
Note that the only information stored on-chain is the channel address and the quantity of the asset held for it;
all other information resides in the off-chain states held by the participants and is only visible on-chain in the case of a dispute.

The \textbf{deposit} operation, $D_\rchi(x)$, is an on-chain operation used to assign $x$ coins to channel $\chi$.
There are no restrictions on who can deposit coins into a channel, but the
transaction must always include a transfer of $x$ coins into the adjudicator.
\begin{align}
D_\rchi(x) \adj{\holds{\rchi}{y}{}} = \adj{\holds{\rchi}{(x + y)}{}}
\end{align}

In order to distribute the coins it holds, a state channel, $\rchi$, must have one or more mechanisms for
registering its outcome, $\Omega$, on-chain.
This registration must be done in a way that ensures that at most one outcome can be registered for each channel. \todo{It seems like `finalized' and `registered' mean the same thing. If so, this should be made clear -- perhaps you should just used `finalized'}
In ForceMove, outcomes are registered either via an unanswered challenge or by the presentation
of a \textit{conclusion proof} - a special set of states signed by participants indicating
that the channel has concluded, thus allowing them to avoid the challenge timeout when withdrawing their funds.
We write $\adj{\holds{\rchi}{}{\Omega}}$ to represent the situation where the outcome $\Omega$ for channel $\rchi$ has been registered on-chain.

Once an outcome is registered on-chain, it can be used to transfer coins between addresses,
through the application of one or more on-chain operations. For example:
\begin{align}\label{eq:on-chain-operations}
  \transfer{\rchi}{A}{x} \adj{\holds{\rchi}{(a + b)}{\Omega}} = \adj{\holds{\rchi}{a}{\Omega'
}, \holds{A}{b}{}}
\end{align}
We will explain this example in further detail in the sections on Turbo and Nitro.\todo{check that this is explained}
In equation (\ref{eq:on-chain-operations}), $A$ could be either a channel address or a participant address.

The \textbf{withdrawal} operation can be used to withdraw coins held at address $A$ by any
party with the knowledge of the corresponding private key. 
Note that the signature requirement coupled with the no-collision assumption means
it is only possible to withdraw from a participant address. \todo{... if you know the private key?}
If $x \leq x'$ then
\begin{align}
W_A(x) \adj{\holds{A}{x'}{}} = \adj{\holds{A}{(x'-x)}{}}
\end{align}
In practice the withdrawal should also specify the blockchain address where the funds should be sent.
A potential method signature is \texttt{withdraw(fromAddr, toAddr, amount, signature)}, 
where \texttt{signature} is $A$'s signature of the other parameters
\footnote{In practice, we add the \texttt{senderAddress} to the parameters to sign,
in order to prevent replay attacks by other parties.}.

In practice, the adjudicator api could allow multiple operations to be executed in a single blockchain transaction.
For example, in the ForceMove SimpleAdjudicator funds are withdrawn in a way such that  
the intermediate state, where funds are held against a participant address, is never persisted on-chain.

\subsection{The Value of a State}\label{section:value-of-a-state}

The utility of a state channel comes from the ability to transfer the value
between participants without the need for an on-chain operation.
In order to reason about state channels, we therefore need to understand how this transfer
of value works.

The word `state' is very overloaded in the world of state channels.
In what follows we will need to distinguish between the state of an individual channel and
the entire state of all channels plus the adjudicator.
We will call the latter the \textbf{network state} and denote it with the symbol $\Sigma$.

We define the \textbf{value}, $\nu_A(\Sigma)$, of a network state $\Sigma$ for participant $A$,
to be the largest $x$ such that $A$ has an unbeatable strategy to extract
\footnote{By \textit{extract} we mean to withdraw $x$ more coins than were deposited in the execution of the strategy.}
$x$ coins from the adjudicator.
The unbeatable strategy can involve signing (or refusing to sign) states off-chain, as well as
applying one or more on-chain operations.
The strategy might have to adapt based on the actions of other players but regardless of
the actions they take, it should still be possible for $A$ to extract $x$ coins.

When evaluating whether a strategy is unbeatable, we make the following assumptions about blockchain transactions:
\begin{enumerate}
  \item \textbf{Transactions are unimpeded}: given that the current time is $t$ and $\epsilon > 0$, then it is possible for any party to apply any operation, $O$, on-chain before time $t + \epsilon$.\todo{Isn't this assumption totally false in practice? Do you mean `There is an $\epsilon > 0$ such that for any $t$, it is possible ...'}
  \item \textbf{Transactions \textit{can} be front-run}: given two parties, $p_1$ and $p_2$, and two operations, $O_1$ and $O_2$, there is no way for $p_1$ to ensure that they can apply $O_1$ to the chain before $p_2$ applies $O_2$.
  \item \textbf{Transactions are free}: we ignore the cost of gas fees when calculating the value of a state.
\end{enumerate}
\todo{You also need a no-offline assumption for the finalizability notion to work.}
The first assumption sidesteps issues of censorship, chain congestion and timing considerations around the creation of blocks.
In practice, this assumption should hold if $\epsilon$ is sufficiently large, which can be accomplished by picking sensible channel timeouts.
The second assumption rules out any strategies that rely on executing a given transaction on-chain before someone else executes a different one.

Throughout this paper we will present sequences of states that interpolate between a start state and a target state, whilst preserving value for all participants.
We will make the argument that, as the value is constant\footnote{
The one exception is any transition involving a deposit, where we assume that a participant depositing
$x$ coins into the network, will proceed if the value of the resulting state for them increases by $x$.
}, participants will be willing to transition between these states.
We call these transitions \textbf{safe transitions}.

If we were considering transactions fees here, we would need to argue this principle more
carefully: with transaction fees, some of the transitions we see as value preserving here
would actually involve moving to a state of slightly lower value. 
We assume that the utility gained in being able to open and close channels off-chain overcomes
this issue in practice.
In general, modelling the effect of gas fees on state channel networks is an interesting and important area of research but falls outside the scope of this paper.

\subsection{Finalizable and Enabled Outcomes}

In this paper, we are not generally concerned with the operation of state channels.
However, in reasoning about channels that fund other channels, we do need to be able to talk about the states of these channels.
It turns out that it is enough to characterise states in terms of the outcomes they allow the participants to register, which allows us to remain agnostic to the precise operation of the channels.
In this section we develop the tools for characterising states in this way.

We say an outcome, $\Omega$, is \textbf{finalizable} for participant $A$, if $A$ has an unbeatable
strategy for registering this outcome in the adjudicator.
We use the notation $\finalizable{\rchi}{\Omega}{A}$, to represent a state of a channel, $\rchi$,
where the outcome, $\Omega$, is finalizable by $A$.
\begin{align}
  \finalizable{\rchi}{\Omega}{A} \xrightarrow{\text{A's unbeatable strategy}} \adj{\holds{\rchi}{}{\Omega}}
\end{align}

It follows from the definition that exactly one of the following statements is true about
a channel $\rchi$ at any point in time:
\begin{enumerate}
  \item Participant $p$ is the unique participant with one or more finalizable outcome(s), $\Omega_1, \dots, \Omega_m$.
        We write this $\finalizable{\rchi}{\Omega_1, \dots, \Omega_m}{p}$.
  \item There are at least two participants, $P = \{p_1, \dots, p_m \}$, who share the same
        finalizable outcome, $\Omega$. We write this $\finalizable{\rchi}{\Omega}{p_1, \dots, p_m}$.
  \item There are no participants with any finalizable outcomes.
\end{enumerate}
The definition of finalizability excludes the case where two different finalizable outcomes are held
by different participants, as in this case at least one participant's strategy would be beatable
by the other participant's strategy.
None of the protocols we present make use of the final situation, where no participant has a finalizable outcome, and we believe this state should generally be avoided.

In the special case where the outcome of a channel is finalizable by all its participants, we say that the outcome is \textbf{universally finalizable}.
This happens at two points of every ForceMove channel's lifecycle:
\begin{enumerate}
  \item After the first $n$ states have been broadcast. In this state, we say the channel is at the \textbf{funding point}.
  \item When a single conclusion proof exists.\todo{is known to each participant?} In this state, we say the channel is in the \textbf{concluded state}.
\end{enumerate}
It is an important property of ForceMove that all channels have one universally finalizable
state at the beginning of their lifecycle and one at the end
\footnote{If a channel does not end with a conclusion proof, it ends with an expired on-chain challenge,
in which case the outcome is already finalized on-chain.}.

If a participant has no finalizable outcomes, their analysis of the network needs to be performed
in terms of their \textbf{enabled outcomes}.
The enabled outcomes for a participant, $p$, is defined as the set of outcomes that $p$ has
no strategy to prevent from being finalized.
We write the set of enabled outcomes for $p$ as $\finalizable{\rchi}{\Omega_1 \dots \Omega_m}{p}$.

For any participant, $p$, in a channel, $\rchi$, exactly one of the following statements is
true at a given point in time:
\begin{enumerate}
  \item $p$ has at least one finalizable outcome.
  \item $p$ has at least two enabled outcomes.
\end{enumerate}
Note that if a participant has only enabled a single outcome, that outcome must be finalizable for them.

\subsection{The Consensus Game}\todo{It's a bit weird to introduce the consensus game here, but say almost nothing about it. I think it would be hard to continue reading without specifying what properties the consensus game has that allows the implementation of transfer.}

Another important example of universally finalizable states comes from the \textbf{consensus game}.
The consensus game is a ForceMove \textit{application}, which means it specifies a certain
set of transitions rules that can be used to define the allowed state transitions for a ForceMove
channel.
We give a complete definition of the consensus game in the appendix.

The rules of the consensus game ensure that it reaches a universally finalizable outcome at least once every $n$ turns, for a channel with $n$ participants.
At a very high level, the consensus game provides a mechanism for moving from one universally
finalizable outcome, $\Omega_1$, to another, $\Omega_2$. 
In order for this to happen, one participant proposes the new outcome, $\Omega_2$, and then
every other participant must sign off on it. 
If any participant disagrees, they can cancel the transition.

The consensus game has some desirable properties in terms of enabling value preserving transitions between network states, which are useful when proving the correctness of state channel network constructions.
Because of this, consensus game channels will feature heavily in Turbo and Nitro protocols.

\section{Turbo Protocol}

The outcome of a Turbo channel is always an \textbf{allocation}.
An allocation is a list of pairs of addresses and totals, $\alloc{a_1{:}v_1, \dots, a_m{:}v_m}$, where each total, $v_i$, represents that quantity of coins due to each address, $a_i$.
If the outcome of channel $A$ includes the pair $B{:}x$, we say that `$A$ \textbf{owes} $x$ to $B$'.
We assume that each address only appears once in the allocation and require that implementations enforce this by ignoring any additional entries for a given address after the first.

The allocation is in priority order, so that if the channel does not hold enough funds to pay all the coins that are due, then the addresses at the beginning of the allocation will receive funds first.
We say that `$A$ \textbf{can afford} $x$ for $B$', if $B$ would receive at least $x$ coins, were the coins currently held by $A$ to be paid out in priority order.

Turbo introduces the \textbf{transfer} operation, $\transfer{A}{B}{x}$, to trigger the on-chain transfer of funds according to an allocation.
If $A$ can afford $x$ for $B$, then $\transfer{A}{B}{x}$:
\begin{enumerate}
  \item Reduces the funds held in channel $A$ by $x$. 
  \item Increases the funds held by $B$ by $x$.
  \item Reduces the amount owed to $B$ in the outcome of $A$ by $x$.
\end{enumerate}
If $A$ cannot afford $x$ for $B$, then $\transfer{A}{B}{x}$ fails, leaving the on-chain state unchanged.

\begin{example}
  In the following example, we have a channel, $L$, which holds $10$ coins and has an outcome, $\alloc{A: 3, B: 2, \rchi: 5}$, which has been registered on-chain.
  As $L$ can afford $5$ for $\rchi$ the following transfer operation is successful:
  \begin{align}
    \transfer{L}{\rchi}{5}\adj{\holds{L}{10}{\alloc{A: 3, B: 2, \rchi: 5}}} = \adj{\holds{L}{5}{\alloc{A:3, B: 2}}, \holds{\rchi}{5}{}}
  \end{align}
\end{example}

We give a python implementation of the Turbo adjudicator in the appendix.

\subsection{Ledger Channels}

A \textbf{ledger} channel is a channel which uses its own funding to fund other channels sharing the same set of participants.
By doing this, a ledger channel allows these \textbf{sub-channels} to be opened, funded and closed without any on-chain operations.

To see how this works, consider the following setup where a ledger channel, $L$, allocates the funds it holds to participants $A$ and $B$ and channel $\rchi$:
\begin{align}
  \adj{\holds{L}{10}{}}, \finalizable{L}{\alloc{A: 2, B: 3, \rchi: 5}}{A, B}
\end{align}
We have chosen the simplest example here, where $L$ is funded by the coins it holds on-chain, but it is completely possible to have ledger channels themselves funded by other ledger channels or (later) by virtual channels.

We claim that the ledger channel $L$ funds the channel $\rchi$ in the above setup.
This is because either participant has the power to convert the situation above into a situation where $\rchi$ is funded on-chain:
\begin{align}
  \transfer{L}{\rchi}{5}\adj{\holds{L}{10}{\alloc{A: 2, B: 3, \rchi: 5}}} = \adj{\holds{L}{10}{\alloc{A: 2, B: 3}, \holds{\rchi}{5}{}}}
\end{align}
After this operation, we say that the channel $\rchi$ has been \textbf{offloaded}.
Note that we do not need to wait for $\rchi$ to complete before offloading it.
The offload converts $\rchi$ from an off-chain sub-channel to an on-chain direct channel, without interrupting its operation in any way.

The offload should be seen as an action of last-resort.
It is important that offloading is allowed so that either player can realize the value in channel $\rchi$ if required, but it has the downside of forcing all sub-channels supported by $L$ to be closed on-chain.
\todo{In practice, with non-zero gas prices, it is ...}It is in the interest of both participants to open and close sub-channels collaboratively.
We next show how this can be accomplished safely.

Under the Turbo protocol, all ledger channels are regular ForceMove channels running the Consensus Game.

\subsubsection{Opening a sub-channel}

The utility of a ledger channel derives from the ability to open and close sub-channels without on-chain operations.
Here we show how to open a sub-channel.
\begin{enumerate}
  \item Start in a state where $A$ and $B$ have a funded ledger channel, $L$, open:
  \begin{align}
    \adj{\holds{L}{x}{}}, \; \finalizable{L}{\alloc{A: a, B: b}}{A, B}
  \end{align}
  \item $A$ and $B$ prepare their sub-channel $\rchi$ and progress it to the funding point. With $a' \leq a$ and $b' \leq b$:
  \begin{align}
    \finalizable{\rchi}{\alloc{A:a', B:b'}}{A,B}
  \end{align}
  \item Update the ledger channel to fund the sub-channel:
  \begin{align}
    \finalizable{L}{\alloc{A:a-a', B: b - b', \rchi: a' + b'}}{A,B}
  \end{align}
\end{enumerate}

\subsubsection{Closing a sub-channel}

When the interaction in a sub-channel, $\rchi$, has finished we need a safe way to update the ledger channels to incorporate the outcome.
This allows the sub-channel to be defunded and closed off-chain.
\begin{enumerate}
  \item We start in the state where $\rchi$ is funded via the ledger channel, $L$. With $x = a + b + c$:
  \begin{align}
    \adj{\holds{L}{x}{}}, \; \finalizable{L}{\alloc{A: a, B: b, \rchi: c}}{A, B}
  \end{align}
  \item The next step is for $A$ and $B$ to concluded channel $\rchi$, leaving the channel in the conclude state. Assuming $a' + b' = c$:
  \begin{align}
    \finalizable{\rchi}{\alloc{A:a', B:b'}}{A,B}
  \end{align}
  \item The participants then update\todo{It's not really clear why a participant would be forced to update the ledger channel in this way.} the ledger channel to include the result of channel $\rchi$.
  \begin{align}
    \finalizable{L}{\alloc{A: a+ a', B: b + b'}}{A, B}
  \end{align}
  \item Now the sub-channel $\rchi$ has been defunded, it can be safely discarded.
\end{enumerate}

\subsubsection{Topping up a ledger channel}

Here we show how a participant can increase their funds held in a ledger channel by depositing into it.
They can do this without disturbing any sub-channels supported by the ledger channel.
\begin{enumerate}
  \item In this process $A$ wants to deposit an additional $a'$ coins into the the ledger channel $L$. We start in the state where $L$ contains balances for $A$ and $B$, as well as funding a sub-channel, $\rchi$. With $x = a + b + c$:
  \begin{align}
    \adj{\holds{L}{x}{}}, \; \finalizable{L}{\alloc{A: a, B: b, \rchi: c}}{A, B}
  \end{align}
  \item To prepare for the deposit the participants update the state to move $A$'s entry to the end, simultaneously increasing $A$'s total. This is a safe operation due to the precedence rules: as the channel is currently underfunded $A$ would still only receive $a$ if the outcome went to chain.
  \begin{align}
    \finalizable{L}{\alloc{B:b, \rchi: c, A: a + a'}}{A,B}
  \end{align}
  \item It is now safe for $A$ to deposit into the channel on-chain:
  \begin{align}
    D_L(a')\adj{\holds{L}{x}{}} = \adj{\holds{L}{x + a'}{}}
  \end{align}
  \item Finally, if required, the participants can reorder the state again:
  \begin{align}
    \finalizable{L}{\alloc{ A: a + a', B: b, \rchi: c}}{A,B}
  \end{align}
\end{enumerate}


\subsubsection{Partial checkout from a ledger channel}

A partial checkout is the opposite of a top up: 
one participant has excess funds in the ledger channel that they wish to withdraw on-chain.
The participants want to do this without disturbing any sub-channels supported by the ledger channels.
\begin{enumerate}
  \item We start with a ledger channel, $L$, that $A$ wants to withdraw $a'$ coins from:
  \begin{align}
    \adj{\holds{L}{x}{}}, \; \finalizable{L}{\alloc{A: a + a', B: b, \rchi: c}}{A, B}
  \end{align}
  \item The participants start by preparing a new ledger channel, $L'$, whose state reflects the situation they want to be in after $A$ has withdrawn their coins. This is safe to do as this channel is currently unfunded.
  \begin{align}
    \finalizable{L'}{\alloc{A: a, B:b, \rchi: c}}{A,B}
  \end{align}
  \item They then update $L$ to fund $L'$ alongside the coins that $A$ wants to withdraw. They conclude the channel in this state:
  \begin{align}
    \finalizable{L}{\alloc{L': a + b + c, A: a'}}{A,B}
  \end{align}
  \item They then finalize the outcome of $L$ on-chain. This can be done without waiting the timeout, assuming they both signed the conclusion proof in the previous step:
  \begin{align}
    \adj{\holds{L}{x}{\alloc{L': a + b + c, A: a'}}}
  \end{align}
  \item $A$ can then call the transfer operation to get their coins under their control. 
  \begin{multline}
    \transfer{L}{A}{a'}\adj{\holds{L}{x}{\alloc{L: a + b + c, A: a'}}} = \\ \adj{\holds{L}{x - a'}{\alloc{L': a + b + c}}, \; \holds{A}{a}{}}
  \end{multline}
  \item At any point in the future the remaining coins can be transferred to $L'$:
  \begin{multline}
    \transfer{L}{L'}{a + b + c}\adj{\holds{L}{x}{\alloc{L: a + b + c}}, \; \holds{A}{a'}{}} =  \\ \adj{\holds{L'}{a + b + c}{}, \; \holds{A}{a'}{}}
  \end{multline}
\end{enumerate}
Note that $A$ was able to withdraw their funds instantly, without having to wait for the channel timeout.


\section{Nitro Protocol}

Nitro protocol is an extension to Turbo protocol.
In Nitro protocol, the outcome of a channel can be either an allocation or a \textbf{guarantee}.
A guarantee outcome specifies a target allocation, whose debts it will help to pay.\todo{target address?}
When paying out debts, the guarantee outcome can choose to modify the payout priority order of its target allocation.

\todo{Suggested rewording in comments}
% A guarantee outcome specifies a target address; the nitro protocol specifies how this guarantee may be used to pay debt on its behalf.
% When paying debt, a guarantee can be used to alter the payout priority of the allocation outcome of its target address. 

We will use the notation $\guar{L}{A, B}$ for a guarantee with target $L$, which prioritizes first $A$, then $B$, then to any other addresses according to the priorities in $L$'s allocation. \todo{This is a strange definition -- it seems like a guarantee must specify the priority of exactly two addresses?}
We say a guarantor channel, $G$, which targets an allocation channel, $L$, `can afford $x$ for $A$\todo{check why this terminology makes sense}', if $A$ would receive at least $x$ coins, were the coins currently held in $A$ to be paid out according to $G$'s reprioritization of $L$'s allocation.\todo{I think this needs some clarification, as the definition of `can afford $x$' is almost circular. Loose suggestion in comments}
% Let $L$ be a channel whose outcome is an allocation $\omega$.
% We say that a guarantor channel $G$ with a finalized guarantee outcome $g$, targeting an allocation channel $L$ `can afford $x$ for $A$' if:
% $transfer_A(x)[[reprioritize(\omega, g)]]$ results with $A$ holding $x$ additional coins.
% (or the equivalent thing said in words)

Nitro adds the \textbf{claim} operation, $\claim{G}{A}{x}$, to the existing transfer, deposit and withdraw operations.
If $G$ acts as guarantor for $L$ and can afford $x$ for $A$, then $\claim{G}{A}{x}$:
% SUGGESTION: If $\adj{\holds{G}{5}{\omega}}$ and, and $G$ can afford $x$ for $A$, then $\claim{G}{A}{x}$ has the following three effects:
\begin{itemize}
  \item Reduces the funds held in channel $G$ by $x$.
  \item Increases the funds held in channel $A$ by $x$.
  \item Reduces the amount owed to $A$ in the outcome of $L$ by $x$.
\end{itemize}
If the outcome of $L$ is not yet registered on-chain, or if $G$ cannot afford $x$ for $A$, then the operation has no effect.
% SUGGESTION: Otherwise, the claim operation has no effect

\begin{example}
  In the following example, we have a guarantor channel, $G$, which holds $5$ coins and guarantees $L$'s allocation, with $\rchi$ as highest priority. \todo{ $\rchi \mapsto B$}
  \begin{multline}
    \claim{G}{B}{5}\adj{\holds{G}{5}{\guar{L}}{B}, \holds{L}{\alloc{A: 5, B: 5}}{}} = \\ \adj{\holds{G}{}{\guar{L}{B}}, \holds{L}{\alloc{A: 5}}{}, \holds{B}{5}{}}
  \end{multline}
  Note that after the claim has gone through, $L$'s debt to $B$ has decreased.
\end{example}

We give a python implementation of the Nitro adjudicator in the appendix. \todo{`of an adjudicator implenenting the Nitro protocol in the appendix'}

\subsection{Virtual Channels}

A virtual channel is a channel between two participants who do not have a shared on-chain deposit, supported through an intermediary.
We give a construction for the simplest possible virtual channel, between $A$ and $B$ through a shared intermediary, $I$. \todo{Virtual channels between larger groups of participants are left as an exercise for the reader :)}

Suppose we have a pair of ledger channels, $L$ and $L'$, with participants $\{A,I\}$ and $\{B,I\}$ respectively.
Assume the following network state.
\begin{align}
  \adj{\holds{L}{x}{}, \holds{L'}{x}{}}, \; \finalizable{L}{\alloc{A:a, I:b}}{A, I}, \; \finalizable{L'}{\alloc{B: b, I: a}}{B, I} \label{eq:virtual-channel-start-state}
\end{align}
where $x = a + b$.
The participants want to use the existing deposits and ledger channels to fund a virtual channel, $\rchi$, with $x$ coins.

In order to do this the participants will need three additional channels: a joint allocation channel, $J$, with participants $\{A, B, I\}$ and two guarantor channels $G$ and $G'$ which target $J$. The setup is shown in figure \ref{fig:virtual-channel-construction}.

\begin{figure}[ht]
  \centering
  \input{figures/virtual-channels-construction}
  \caption{Virtual channel construction}
  \label{fig:virtual-channel-construction}
\end{figure}

We will cover the steps for safely setting up this construction in section \ref{section:open-close-virtual-channel}. 
In the remainder of this section we will explain why this construction can be considered to fund the channel $\rchi$. \todo{In section \ref{section:offloading virtual channels}, we will explain ...}
Similarly to the method for ledger channel construction, we will do this by demonstrating how any one of the participants can offload the channel $\rchi$: converting it to an on-chain channel that holds its own funds.
\todo{Shouldn't you also show how the participants can jointly update }

\subsection{Offloading Virtual Channels}\label{section:offloading virtual channels}

We will first consider the case where $A$ wishes to offload $\rchi$. $A$ proceeds as follows:
\begin{enumerate}
  \item $A$ starts by registering all their finalizable outcomes on-chain:
  \begin{align}
    \adj{\holds{L}{x}{\alloc{G:x}}, \; \holds{L'}{x}{}, \holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{align}\todo{A can't finalize $L'$, only $L$ and $J$.}
  \item $A$ then calls $\transfer{L}{G}{x}$ to move the funds from $L$ to $G$:
  \begin{align}
    \adj{\holds{L'}{x}{}, \holds{G}{x}{\guar{J}{\rchi, A, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{align}
  \item Finally $A$ calls $\claim{G}{A}{\rchi}$ to move the funds from $G$ to $\rchi$.
  \begin{align}
    \adj{\holds{L'}{x}{}, \holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{J}{}{\alloc{I: x}}, \; \holds{\rchi}{x}{}}
  \end{align}
\end{enumerate}
As $G$ has $\rchi$ as top priority, the operation is successful.

By symmetry, the previous case also covers the case where $B$ wants to offload.
The final case to consider is the one where $I$ wants to offload the channel and reclaim their funds.
This is important to ensure that $A$ and $B$ cannot lock $I$'s funds indefinitely in the channel.
We assume that $I$ has started by registering all their finalizable channels on-chain, followed by transferring funds from $L$ to $G$ and from $L'$ to $G'$. \todo{This sentence seems redundant, given that the steps are laid out in detail below}
\begin{enumerate}
  \item $I$ starts by registering all their finalizable outcomes on-chain:
  \begin{multline}
    \adj{\holds{L}{x}{\alloc{G:x}}, \; \holds{L'}{x}{\alloc{G':x}}, \holds{G}{}{\guar{J}{\rchi, A, I}}, \; \\\holds{G'}{}{\guar{J}{\rchi, B, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{multline}
  \item $I$ then transfers funds from the ledger channels to the virtual channels by calling $\transfer{L}{G}{x}$ and $\transfer{L'}{G'}{x}$:
  \begin{align}
    \adj{\holds{G}{x}{\guar{J}{\rchi, A, I}}, \; \holds{G'}{x}{\guar{J}{\rchi, B, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{align}
  \item Then $I$ claims on one of the guarantees, e.g. $\claim{G}{\rchi}{x}$ to offload $\rchi$:
  \begin{align}
    \adj{\holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{G'}{x}{\guar{J}{\rchi, B, I}}, \; \holds{J}{}{\alloc{I: x}}, \; \holds{\rchi}{x}{}}
  \end{align}
  \item After which, $I$ can recover their funds by claiming on the other guarantee, $\claim{G'}{I}{x}$:
  \begin{align}
    \adj{\holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{G'}{}{\guar{J}{\rchi, B, I}}, \;  \holds{\rchi}{x}{}, \; \holds{I}{x}{}}
  \end{align}
\end{enumerate}
\begin{multline}
  \claim{G'}{G}{I}\claim{G}{\rchi}{x}\adj{\holds{G}{x}{\guar{J}{\rchi,A,I}}, \holds{G'}{x}{\guar{J}{\rchi, B, I}},\\ \holds{J}{}{\alloc{\rchi: x, I: x}}} =
  \adj{\holds{L'}{x}{}, \holds{\rchi}{x}{}, \holds{I}{x}{}}
\end{multline}\todo{This equation isn't needed, and also appears to be nonsense}
Note that $I$ has to claim on both guarantees, offloading $\rchi$ before being able to reclaim their funds.
The virtual channel became a direct channel and the intermediary was able to recover their collateral.

As in Turbo, the offload is an action of last resort and virtual channels are designed to be opened and closed entirely off-chain.
We now show how this can be accomplished.\todo{This paragraph seems better suited at the end of subsection 5.1, or at the start of subsection 5.3}

\subsection{Opening and Closing Virtual Channels}\label{section:open-close-virtual-channel}

In this section we present a sequence of network states written in terms of universally finalizable outcomes, where each state differs from the previous state only in one channel.
We claim that this sequence of states can be used to derive a safe procedure for opening a virtual channel, where the value of the network remains unchanged throughout for all participants involved.
We justify this claim in the appendix.

The procedure for opening a virtual channel is as follows:\todo{It seems like this section requires a proof of safety at each step, perhaps in the index.}
\begin{enumerate}
  \item Start in the state given in equation (\ref{eq:virtual-channel-start-state}):
  \begin{align}
    & \adj{\holds{L}{x}{}, \holds{L'}{x}{}}\\
    & \finalizable{L}{\alloc{A:a, I:b}}{A, I} \\
    & \finalizable{L'}{\alloc{B: b, I: a}}{B, I}
  \end{align}
  \item $A$ and $B$ bring their channel $\rchi$ to the funding point:
  \begin{align}
    \finalizable{\rchi}{\alloc{A:a, B:b}}{A,B}
  \end{align}
  \item In any order, $A$, $B$ and $I$ setup the virtual channel construction:
  \begin{align}
    & \finalizable{J}{\alloc{A:a, B:b, I: x}}{A, B, I} \\
    & \finalizable{G}{\guar{J}{\rchi, A, I}}{A, I} \\
    & \finalizable{G'}{\guar{J}{\rchi, B, I}}{B, I}
  \end{align}
  \item In either order switch the ledger channels over to fund the guarantees:
  \begin{align}
    & \finalizable{L}{\alloc{G: x}}{A,I} \\
    & \finalizable{L'}{\alloc{G': x}}{B,I}
  \end{align}
  \item Switch $J$ over to fund $\rchi$:
  \begin{align}
    \finalizable{J}{\alloc{\rchi: x, I: x}}{A, B, I}
  \end{align}
\end{enumerate}
We give a visual representation of this procedure in figure \ref{fig:virtual-channel-opening}.

\begin{figure}[ht]
  \centering
  \input{figures/virtual-channels}
  \caption{Opening a virtual channel}
  \label{fig:virtual-channel-opening}
\end{figure}

The same sequence of states, when taken in reverse, can be used to close a virtual channel:
\begin{enumerate}
  \item Participants $A$ and $B$ finalize $\rchi$ by signing a conclusion proof:
  \begin{align}
    \finalizable{\rchi}{\alloc{A:a', B:b'}}{A,B}
  \end{align}
  \item $A$ and $B$ sign an update to $J$ to take account of the outcome of $\rchi$. $I$ will accept this update, provided that their allocation of $x$ coins remains the same:
  \begin{align}
    \finalizable{J}{\alloc{A: a', B:b', I: x}}{A, B, I}
  \end{align}
  \item In either order switch the ledger channels to absorb the outcome of $J$, defunding the guarantor channels in the process:
  \begin{align}
    & \finalizable{L}{\alloc{A: a', I: b'}}{A,I} \\
    & \finalizable{L'}{\alloc{B: b', I: a'}}{B,I}
  \end{align}
  \item The channels $\rchi$, $J$, $G$ and $G'$ are now all defunded, so can be discarded
\end{enumerate}

It is also possible to do top-ups and partial checkouts from a virtual channel.\todo{I feel like you should explain how to do this. It should be possible to reduce it to the partial checkout process from section 4.}

\section{Acknowledgements}

- Andrew Stewart
- George Knee
- James Prestwich
- Chris Buckland
- Magmo team

\newpage

\section{Appendix}

THIS APPENDIX IS STILL A WIP.

\subsection{Overview of ForceMove}





\subsection{The Consensus Game}

The Consensus Game is an important ForceMove application, which we will use heavily in the rest of the paper due to its special properties regarding outcome finalizability. In this section we introduce transition rules and explore these properties.

Like all ForceMove applications, the transition rules for the Consensus Game are specified by a game library, $L_C$, which defines the transition function, $t_{L_C}$, in terms of the turn number, $i$, the balances, $\beta$ and the game data $\delta$. $\delta = (j, x)$, where $j$ is the \textit{consensus counter} and $x$ is the \textit{proposed balances}. 
\begin{align*}
  t_{L_C}(i, \beta, (j, x), \beta', (j', x')) \Leftrightarrow
    [ & (j=n-1 \wedge j'= 0 \wedge \beta' = x = x')  \vee \\
    & (j < n-1 \wedge j' = j+1, \beta = \beta', x = x') \vee \\
    & (j'=0, \beta = \beta') ]
\end{align*}
For a given $\beta$, the consensus counter will increase from $0\dots (n-1)$ as the participants sign off on the new balances. Once all participants have signed, consensus has been reached and the channel's balances are updated.

  \begin{align*}
    \sigma^{i}(\beta, (0, \beta)) & \approx [\beta]_P \\
    \sigma^{i+1}(\beta, (0, \beta')) & \approx \{\beta'\}_{p_0}[\beta]_{p_1, ..., p_{n-1}} \\
    \sigma^{i+2}(\beta, (1, \beta')) & \approx \{\beta'\}_{p_0, p_1}[\beta]_{p_2, ..., p_{n-1}} \\
    &\vdots\\
    \sigma^{i+n-1}(\beta, (n-1, \beta')) & \approx [\beta', \beta]_{p_{n-1}} \\
    \sigma^{i+n}(\beta', (0, \beta')) & \approx [\beta']_{P} \\
  \end{align*}


\subsection{Proofs of Correctness}

- what do we need to prove?
- we showed that 

- if we two universally finalizable states, $\sigma$, $\sigma'$
- in a consensus game channel with $n$ participants
- that are value preserving for all participants
- then it is possible to find a set of $n$ state updates that preserve value for all participants and which move from $\sigma$ and $\sigma'$


\subsection{Virtual Channels on Turbo}
\subsection{Payouts to Non-Participants}
\subsection{Possible Extensions}

\subsection{On-chain Operations Code}
\subsubsection{Overlap}
\begin{minipage}{\linewidth} % minipage to avoid page breaks
  \lstinputlisting[language=Python]{code/overlap.py}
\end{minipage}


\end{document}
