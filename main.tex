\input{preamble}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{bm}
\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]

\newcommand{\adj}[1]{\llbracket #1 \rrbracket} 
\newcommand{\enf}[1]{[#1]} 

\begin{document}

\maketitle

\section{Recap of ForceMove}

The ForceMove protocol describes the message format and the supporting on-chain behaviour
to enable generalized, $n$-party state channels on any blockchain that supports Turing-complete, general-purpose
computation. Here we give a brief overview of the protocol to the level required to understand
the rest of the paper. For a more comprehensive explanation please refer to \cite{}.

A ForceMove \textbf{state channel}, $\chi(P, L, k)$, is defined by an ordered set of participant
addresses, $P = [p_0, ..., p_{n-1}]$, the address of an on-chain \textbf{game library}, $L$,
and a nonce, $k$, which chosen by the first participant to make the channel's combination of properties unique.
The \textbf{channel address} is calculated by taking the last 20 bytes of the \texttt{keccak256}
hash of the channel properties. 

\begin{table}[h]
  \begin{tabular}{|l|l|l|p{5cm}|}
    \hline
    \texttt{participants} & \texttt{address[]} & $P$ & The addresses used to sign updates to the channel. \\ \hline
    \texttt{gameLibrary} & \texttt{address} & $L$ & The address of the gameLibrary, which defines the transition rules for this channel \\ \hline
    \texttt{nonce} & \texttt{unit256} & $k$ & Chosen to make the channel's address unique. \\ \hline
    \texttt{challengeDuration} & \texttt{unit256} & $\eta$ & \\ \hline
    \texttt{turnNum} & \texttt{unit256} & $i$ & Increments as new states are produced. \\ \hline
    \texttt{balances} & \texttt{(address, uint256)[]} & $\beta$ & Current \textit{outcome} of the channel. \\ \hline
    \texttt{isFinal} & \texttt{bool} & $f$ & \\ \hline
    \texttt{data} & \texttt{bytes} & $\delta$ & \\ \hline
    \texttt{v} & \texttt{uint8} & &  ECDSA signature of the above arguments by the moving participant. \\ \cline{1-2}
    \texttt{r} & \texttt{bytes32} & & \\ \cline{1-2}
    \texttt{s} & \texttt{bytes32} & & \\ \hline
  \end{tabular}
  \caption{ForceMove state format}
  \label{table:force-move-state}
\end{table}

A ForceMove \textbf{state}, $\sigma_\chi^i(\beta, f, \delta)$, is specified by \textbf{turn number}, $i$,
a set of \textbf{balances}, $\beta$, a boolean flag \textbf{finalized}, $f \in \{T, F\}$, and
a chunk of unstructured \textbf{game data}, $\delta$, that will be interpreted by the game library. The
balances can be thought of as an ordered set of $(\texttt{address}, \texttt{uint256})$ pairs,
which specify how any funds allocated to the channel should be distributed if the channel 
were to finalize in the current state.

In order for a state, $\sigma_\chi^i$, to be valid it must be signed by participant, $p_j$,
where $j = i \% n$ is the remainder mod $n$. This requirement specifies that participants
in the channel must take turns when signing states.

The game library is responsible for defining a set of states and allowed transitions that
in turn define the `application' that will run inside the state channel. It does this by
defining a single boolean function, $t_L(i, \beta, \delta, \beta', \delta') \rightarrow \{ T, F\}$.
This function is used to derive an overall boolean transition function, $t$, specifying whether
a transition between two states is permitted under the rules of the protocol:
\begin{align*}
  t(\sigma_\chi^i(\beta, f, \delta), \sigma_{\chi'}^j(\beta', f', \delta') ) \Leftrightarrow &
    \chi = \chi'
    \wedge j = i + 1
    \wedge \\
    & [ (\neg f \wedge \neg f' \wedge j \leq 2n \wedge \beta = \beta' \wedge \delta = \delta') \vee \\
    & (\neg f \wedge \neg f' \wedge j > 2n \wedge t_L(n, \beta, \delta, \beta', \delta')) \vee \\
    & (f' \wedge \beta = \beta' \wedge \delta' = 0) ]
\end{align*}

In all transitions the channel properties must remain unchanged and the turn number must increment.
There are then three different modes of operation. The first mode applies in the first $2n$
states (assuming none of these are finalized) and in this mode the balances and game data
must remain unchanged. As we will see later, these states exist so that the channel can be
funded safely. We refer to the first $n$ states as the \textbf{pre-fund setup} states and
the subsequent $n$ as the \textbf{post-fund setup} states. The second mode applies to the
`normal' operation of the channel, when the game library is used to determine the allowed
transitions. The final mode concerns the finalization of the channel: at any point the current
participant can choose to exit the channel and lock in the balances in the current state.
Once this happens the only allowed transitions are to additional finalized states. Because
of this, we have no further use for the game data, $\delta$, so can remove this from the state.
Once a sequence of $n$ finalized states have been produced the channel is considered closed. We
call this sequence of $n$ finalized states a \textbf{conclusion proof}, which we will write $\bm{\sigma}^*$.

\input{figures/game-overview}

\subsection{On-chain operations}

todo: intro
We will talk about the adjudicator as though it is a single contract but don't intend to take a position on how it should be constructed by doing so; it is likely that in practice the adjudicator functionality will be provided by a set of interacting contracts.

We will refer to the on-chain contract as the \textbf{adjudicator}, which we will write $\adj{S}$, where $S$ represents the contract's internal state. The state consists of three collections: the allocations, the outcomes and the challenges, each of which is keyed by a channel address. 

The \textbf{allocations} collection is an \texttt{(address -> uint256)} mapping that records the total funds allocated to a given channel. We write $\adj{\alpha_\chi(x)}$ to represent an adjudicator where $x$ is allocated to channel $\chi$.

The \textbf{outcomes} collection assigns channels to one of two different modes: channels are either undecided or decided. We use the symbol $\top$ to represent undecided channels, so that $\adj{\beta_\chi(\top)}$ represents an adjudicator where the outcome of channel $\chi$ is undecided. For channels with outcomes that are decided, the outcomes collection maps the channel address to an ordered set of \texttt{(address, uint256)} pairs - exactly the same format as the channel balances. We write $\adj{\beta_\chi(X: x, Y: y)}$ for an adjudicator where the outcome for channel $\chi$ is decided and sends $x$ to address $X$ and $y$ to address $Y$.

The \textbf{challenges} collection records whether there is an open challenge on a given channel. We write $\adj{\kappa_\chi(\tau, \sigma)}$ for the case where there's an open challenge on channel $\chi$ challenging with state $\sigma$ and expiring at time $\tau$. We write $\adj{\kappa_\chi(\top)}$ in the case where there is no open challenge and $\adj{\kappa_\chi(\bot)}$ in the case where a challenge has expired (and thus no further challenges are possible). An efficient real-world implementation would most likely store the challenges as part of the outcomes collection, but we have chosen to treat them as separate concepts for the purpose of this paper.

Note that while using the above notation in the rest of the paper, we will suppress the unimportant parts of the state, with the understanding that these parts of the state remain unchanged. It is also understood that zero entries can be ignored in outcomes, so that $\beta(a_1: 0, a_2:x_2,...) \equiv \beta(a_2:x_2, ...)$.

We now move on to describing the operations supported by the adjudicator. The first operation we look at is the \textbf{deposit}:
\begin{align*}
D_\chi(x) \adj{\alpha_\chi(y)} \rightarrow \adj{\alpha_\chi(x + y)}
\end{align*}
The deposit can be called by anyone and results in an increase in the allocation for the given channel.

There is also a \textbf{withdrawal} operation that can be use to withraw funds allocated to an address by an outcome.
\begin{align*}
W_A(x) \adj{\alpha_\chi(x + y)\beta_\chi(A: x + z, ...)} \rightarrow \adj{\alpha_\chi(y)\beta_\chi(A: z, ...)}
\end{align*}
In order to call the withdraw, the caller needs to sign the withdraw operation using the private key of the address they're withdrawing from. Thus it is not possible to call the withdraw operation for an address that corresponds to a state channel, as these addresses were generated from a hash of the channel's properties and not from a public/private key pair.

The next operation is the \textbf{force-move} which is used to register a challenge in the adjudicator:
\begin{align*}
FM(\tau, \sigma^i, ..., \sigma^{i+n-1}) \adj{\kappa_\chi(\top)} \rightarrow \adj{\kappa(\tau + \eta, \sigma^{i+n-1})}
\end{align*}

The intent of a force-move is to get the next participant to provide their next move to the adjudicator. To do this they can call the \textbf{respond} method, providing their next state:
\begin{align*}
R(\tau', \sigma^{i+1})\adj{\kappa(\tau, \sigma^i)} \rightarrow \adj{\kappa_\chi(\top)}
\end{align*}
Once the challenge is cancelled it is removed from the adjudicator and the channel operation can continue off-chain. The force-move paper \cite{} outlines a couple of alternative ways (\textbf{refute} and \textbf{respond-with-alternative-move}) to respond to a force-move. While these are important for the ForceMove protocol, we will not need them in this paper, so will not go over them here.

If the opponent does not respond to the challenge before the challenge expiry time, $\tau$, then a \textbf{timeout} occurs:
\begin{align*}
\Theta(\tau + \epsilon) \adj{\kappa(\tau, \sigma_\chi(\beta_\chi, \delta))} \rightarrow \adj{\beta_\chi \kappa_\chi(\bot)}
\end{align*}
Unlike the other operations on this list, the timeout operation is not triggered by a
blockchain transaction. Instead the operation happens automatically when the block time
exceeds the expiry time stored in the challenge. In practice, there will not be any change 
to the state stored in the contract when the operation occurs - just a change to the
interpretation of that state. 

The final operation is the \textbf{conclude} operation, which enables the immediate creation of a channel outcome from a conclusion proof, $\bm{\sigma}^*(\beta)$ including in the case where there is an active challenge:
\begin{align*}
C(\tau, \bm{\sigma}^*(\beta)) \adj{\kappa_\chi(x)} \rightarrow 
\begin{cases}
  \adj{\kappa_\chi(\bot)} & \text{if } x = \bot \\
  \adj{\beta_\chi(\beta) \kappa_\chi(\bot)} &
  \text{otherwise}
\end{cases}
\end{align*}
The conclude operation enables instant withdrawals in the case the channel is concluded collaboratively off-chain.





\section{Outcomes and Ownership}

Own an outcome. Prepared. Possible. Enabled.
Enforceable / Enabled

As shown in the previous section, at the end of a ForceMove channel the final balances $\beta$ are \textbf{registered} with the adjudicator, either via an expired force-move or via a conclusion proof. We will refer to these final balances as the \textbf{outcome} of the channel. In this section, we will examine channel outcomes and introduce the concept of outcome ownership that underpins the rest of the paper.

We say an outcome, $\beta$ is an \textbf{owned outcome} for a participant, $p$, if no other participant can prevent $p$ from registering $\beta$ with the adjudicator. We write this $\enf{\beta}_p$.

TODO: do we need to talk about "before next turn".

\begin{exmp}
  \textbf{The Next Mover's Ownership} \\
  Take a ForceMove channel where all $n$ participants possess states $\sigma_0, \dots, \sigma_m$, where $m \geq n$. Let $p$ be the participant whose turn it is to sign $\sigma_{m+1}$ (so that $p = p_i$ where $i = (m+1)\%n)$. 

  Then if $\beta = \sigma_m.\beta$ the $\beta$ is owned by $p$, $\enf{\beta}_p$. In particular, no other participant can prevent $p$ from 
  creating a force-move $FM(\tau, \sigma_{m-n}, \dots, \sigma_n)$ and then waiting for it to time out.
\end{exmp}

We say a set of outcomes, $\{ \beta_1, \dots, \beta_n \}$, are an \textbf{unonwned} set of outcomes for $p$, if it's possible for $p$ to cause one of the outcomes to be registered with the adjudicator but it isn't possible for $p$ to choose which one.

Here are some facts about outcomes:
\begin{itemize}
  \item It is possible for multiple participants to own the same outcome similtaneously. We write this $\enf{\beta}_{p_1, p_2}$.
  \item It is possible for one participant to own multiple outcomes simulateously. We write this $\enf{\beta_1, \beta_2}_p$.
  \item It is impossible for different participants to own different outcomes similtaneously.
  \item If one participant holds multiple outcomes it isn't possible for another participant to hold
  \item Is possible that no participant owns any outcomes.
  \item Only a channel's participants can own an outcome in the channel.
\end{itemize}


\begin{exmp}
  \textbf{Conclusion proofs} \\
  hello
\end{exmp}

\begin{exmp}
  \textbf{PreFundSetup} \\
  hello
\end{exmp}

\begin{exmp}
  \textbf{The consensus game} \\
  \begin{align*}
    t_{L_C}(i, \beta, (j, x), \beta', (j', x')) \Leftrightarrow
      [ & (j=n-1 \wedge j'= 0 \wedge \beta' = x = x')  \vee \\
      & (j < n-1 \wedge j' = j+1, \beta = \beta', x = x') \vee \\
      & (j'=0, \beta = \beta') ]
  \end{align*}

  \begin{align*}
    \sigma^{i}(\beta, (0, \beta)) & \approx [\beta]_P \\
    \sigma^{i+1}(\beta, (0, \beta')) & \approx \{\beta'\}_{p_0}[\beta]_{p_1, ..., p_{n-1}} \\
    \sigma^{i+2}(\beta, (1, \beta')) & \approx \{\beta'\}_{p_0, p_1}[\beta]_{p_2, ..., p_{n-1}} \\
    &\vdots\\
    \sigma^{i+n-1}(\beta, (n-1, \beta')) & \approx [\beta', \beta]_{p_{n-1}} \\
    \sigma^{i+n}(\beta', (0, \beta')) & \approx [\beta']_{P} \\
  \end{align*}
    hello
\end{exmp}


We say a state $\adj{S}$ is $\alpha_X$-equivalent to a state $\alpha_X(x)$ if there exist
a sequence of on-chain operations $O = O_i \dots O_0$ such that the $\alpha_X$ term in
$\adj{S'} = O\adj{S}$ is at least $x$ ($\alpha_X$-reachable) and there is no sequence of
operations $O'$ such that $\alpha_x(x)$ is not reachable from the resulting state
$\adj{S''} = O'\adj{S}$ 

On-chain funding

\subsection{The consensus game}


\section{Turbo Protocol}

Turbo protocol is a small extension to ForceMove that allows multiple ForceMove state
channels between a the same set of participants to be supported by a single on-chain
state deposit.

* parallelized
* open and close off-chain
* generalisation of addresses

In Turbo the ForceMove withdrawal operation, $W_A(x)$, is replaced with two operations: a
\textbf{transfer} operation, $T_{A,B}(x)$, and a modified withdrawal operation, $W'_B(x)$.
The original ForceMove withdrawal can be recovered as $W_A(x) = W'_B(x)T_{A,B}(x)$.

The modified withdrawal operation, $W'_A(x)$, allows withdrawal directly from the funds
held for address, $A$. The operation requires knowledge of the private key of $A$ and is
therefore not possible for addresses that correspond to state channels. The operation has
the following effect on the on-chain state:
\begin{align*}
W'_A(x) \adj{\alpha_A(x')} \rightarrow \adj{\alpha_A(x'-x)}
\end{align*}

The transfer operation, $T_{A,B}(x)$, is an instruction to transfer funds currently allocated
to address $A$ to address $B$, according to the outcome of channel $A$:
\begin{multline*}
T_{AB}(x) \adj{\alpha_A(x_\alpha)\beta_A(B:x_\beta, \dots)} \rightarrow \\
  \begin{cases}
      \adj{\alpha_A(x_\alpha - x)\alpha_B(x)\beta_A(B:x_\beta - x, \dots)} & 
      \text{if } x \leq x_\alpha, x_\beta \\
      \adj{\alpha_A(x_\alpha)\beta_A(B:x_\beta, \dots)} &
      \text{otherwise}
  \end{cases}
\end{multline*}



Off-chain open and close


\section{Nitro Protocol}

Add extra type of channels
Guarantor terms

\begin{table}[h]
  \begin{tabular}{|l|l|l|p{5cm}|}
    \hline
    \texttt{participants} & \texttt{address[]} & $P$ & The addresses used to sign updates to the channel. \\ \hline
    \texttt{gameLibrary} & \texttt{address} & $L$ & The address of the gameLibrary, which defines the transition rules for this channel \\ \hline
    \texttt{nonce} & \texttt{unit256} & $k$ & Chosen to make the channel's address unique. \\ \hline
    \texttt{challengeDuration} & \texttt{unit256} & $\eta$ & \\ \hline
    \texttt{turnNum} & \texttt{unit256} & $i$ & Increments as new states are produced. \\ \hline
    \texttt{guarantorFor} & \texttt{address} &  & Target channel for guarantee channels. Equal to 0 for balance channels. \\ \hline
    \texttt{balances} & \texttt{(address, uint256)[]} & $\beta$ or $\gamma$ & Current \textit{outcome} of the channel. \\ \hline
    \texttt{isFinal} & \texttt{bool} & $f$ & \\ \hline
    \texttt{data} & \texttt{bytes} & $\delta$ & \\ \hline
    \texttt{v} & \texttt{uint8} & &  ECDSA signature of the above arguments by the moving participant. \\ \cline{1-2}
    \texttt{r} & \texttt{bytes32} & & \\ \cline{1-2}
    \texttt{s} & \texttt{bytes32} & & \\ \hline
  \end{tabular}
  \caption{ForceMove state format}
  \label{table:force-move-state}
\end{table}

\begin{multline*}
G_{ABC}(x) \adj{\alpha_A(x_\alpha)\gamma_{A,B}(C:x_\gamma, \dots)\beta_B(\dots, C:x_\beta, \dots)} \rightarrow \\
  \begin{cases}
      \adj{\alpha_A(x_\alpha - x)\alpha_C(x)\gamma_{A,B}(C:x_\beta -x, \dots)\beta_B(\dots, C:x_\beta - x, \dots)} \\
      \hspace{7cm} \text{if } x \leq x_\alpha, x_\beta, x_\gamma \\
      \adj{\alpha_A(x_\alpha)\gamma_{A,B}(C:x_\gamma, \dots)\beta_B(\dots, C:x_\beta, \dots)} \\
      \hspace{7cm} \text{otherwise}
  \end{cases}
\end{multline*}

\subsection{Virtual Channels}

There is a configuration where we can support virtual channels.
They can be opened and closed off-chain.

Want to fund a channel $\chi$ between A and B, for which we have state $\enf{\beta_\chi(A: x, B:y)}_{A,B}$. We have channels $L$ and $L'$ with participants $\{A, C\}$ and $\{B, C\}$ respectively. We assume these channels start in states $\enf{\beta_L(A:x, C:)}$

\begin{align*}
  \adj{\alpha_L(x)\alpha_{L'}(x)} \quad \enf{\beta_L(A: a, C: b)}_{A,C} \quad \enf{\beta_{L'}(B:b, C:a)}_{B, C}
\end{align*}

\begin{align*}
  & \adj{\alpha_L(x)\beta_L(G: x)\gamma_{G,J}(\chi: x, C: x)\beta_J(\chi: x, C: x)\beta_\chi(A: a, B: b)}\\ 
  & \begin{aligned}
   \xrightarrow{T_{L,G}(x)} & \adj{\alpha_G(x)\gamma_{G, J}(\chi: x, C: x)\beta_J(\chi: x, C: x)\beta_\chi(A: a, B: b)} \\
   \xrightarrow{G_{G, J, \chi}(a)} & \adj{\alpha_\chi(x)\beta_\chi(A: a, B: b)\gamma_{G, J}(C: x)\beta_J(C: x)} \\
   \xrightarrow{T_{\chi, A}(a)} & \adj{\alpha_A(a)\alpha_\chi(b)\beta_\chi(B: b)\gamma_{G, J}(C: x)\beta_J(C: x)} \\
   \approx & \alpha_A(a)
  \end{aligned}
\end{align*}




\begin{figure}[h]\centering
  \begin{tikzpicture}[x=3cm,y=1cm]

    % Specification of nodes (position, etc.)
    \node (a0) at (-1,0) { $\adj{\alpha_L(x)}$ };
    \node (a1) at (1,0) { $\adj{\alpha_{L'}(x)}$ };
    \node (b0) at (-1,-1) { $\enf{\beta_L(G: x)}_{A, C}$ };
    \node (b1) at (1,-1) { $\enf{\beta_{L'}(G': x)}_{B, C}$ };
    \node (g0) at (-1,-2) { $\enf{\gamma_{G, J}(\chi: x, A: x, C: x)}_{A, C}$ };
    \node (g1) at (1,-2) { $\enf{\gamma_{G', J}(\chi: x, B: x, C: x)}_{B, C}$ };
    \node (j) at (0,-3) { $\enf{\beta_J(\chi: x, C: x)}_{A,B,C}$ };
    \node (c) at (0,-4) { $\enf{\beta_\chi(A: a, B: b)}_{A,B}$ };

    \begin{scope}[-]
      \tikzstyle{every node}=[draw=none,below]
      \draw (a0) to (b0);
      \draw (a1) to (b1);
      \draw (b0) to (g0);
      \draw (b1) to (g1);
      \draw (g0) to (j);
      \draw (g1) to (j);
      \draw (j) to (c);
    \end{scope}

  \end{tikzpicture}
\caption{Ledger channels, $x = a + b$}\label{fig:modes}
\end{figure}

\section{Assumptions}:
* Can register a transaction within any blockchain interval
* Transactions are free

\end{document}
