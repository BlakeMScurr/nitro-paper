\documentclass{article}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{color}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows.meta,backgrounds}
\usepackage{etoolbox}
\usepackage{url} % for urls in bibliography
\usepackage[parfill]{parskip} % no paragraph indents, leave blank line
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{listings}

\graphicspath{ {./drawio/} }

% Need this to keep the space before theorems when using parfill parskip
% https://tex.stackexchange.com/questions/25346/wrong-spacing-before-theorem-environment-amsthm
\begingroup
    \makeatletter
    \@for\theoremstyle:=definition,remark,plain\do{%
        \expandafter\g@addto@macro\csname th@\theoremstyle\endcsname{%
            \addtolength\thm@preskip\parskip
            }%
        }
\endgroup

\DeclareRobustCommand{\rchi}{{\mathpalette\irchi\relax}}
\newcommand{\irchi}[2]{\raisebox{\depth}{$#1\chi$}} % inner command, used by \rchi

\title{Nitro Protocol}
\author{Tom Close}

\usepackage{mathtools}
\usepackage{bm}
\usepackage{stmaryrd} % for llbracket and rrbracket

\theoremstyle{definition}
\newtheorem{example}{Example}[section]
\newtheorem{defn}{Definition}[section]

\newcommand{\adj}[1]{\llbracket #1 \rrbracket} 
\newcommand{\enf}[1]{[#1]} 

\newcommand{\holds}[1]{: #1} 
\newcommand{\allocs}[2]{\rightarrow ( #1 )_{#2}} 
\newcommand{\guars}[3]{\rightarrow ( #1 \sim #2 )_{#3}} 

\begin{document}

\maketitle

\section{Motivation}

A blockchain is a device that enables a group of adversarial parties to come to consensus over the contents of a shared ledger, without appealing to a trusted central authority. 
Whether using a proof-of-work or a proof-of-stake algorithm, this process has a cost both in terms of time and in terms of money.
For the Ethereum blockchain, this cost results in an effective limit of around 15 transactions per second being processed on the network.
When compared with the visa network, which can process on the order of 50,000 transactions per second, this limit supports the view that blockchains, in their current form, do not scale.

State channels offer a solution to the blockchain scaling problem.
A state channel can be thought of as a set of updatable agreements between a fixed set of participants determining how a given set of assets should be split between them.
The agreements are updated off-chain through the exchange of cryptographically signed messages between the participants according to some set of previously-agreed update rules. 
The assets in question are held in escrow on the blockchain, in such a way
that they can only be released according to the latest agreement from the state channel.
If the off-chain cooperative behaviour breaks down, for example if one party refuses to sign updates either by choice or due to unavailability, any of the parties can reclaim their share of the assets by presenting the latest agreement to the chain.
An exit game is required to give other parties the opportunity to present a later state, but all parties have the guarantee that they can reclaim their share of the funds within some finite time.

In addition to the increased throughput, state channels bring instant finality to transactions: the moment a channel update is received the participant knows that the assets transferred are now assigned to them.
They cannot access the assets immediately but they have the power to prevent any other party claiming those assets in the future.
The only requirement is that participants need to be live enough to engage in the exit game if an opponent attempts to exit an earlier state.
In practice, the requirement here is to check the chain periodically - at time intervals that are less than, but on the same order of magnitude as, the challenge duration in the exit game.

As the channel updates are created and exchanged off-chain, the channel-update throughput is limited only by the speed of constructing, signing and broadcasting the update.
Given that channel updates only needed to be communicated between participants and the system is therefore highly parallelizable, it is difficult to put a bound on the total transaction throughput of a system of state channels.
In practice the system is only limited by the on-chain operations required to move assets when opening and closing channels.

In this paper, we allow channels to be opened and closed off-chain. We enable the construction of efficient state channel networks.[TODO]

\section{Existing work}

Lightning and raiden
- payment channel networks
- directional

Celer
- directional but with multiple paths
- general conditions

Perun
- virtual payment channels (different from HTLCs)
- but using a validity time
- and then state channel networks
- constrained
[Connext - have removed the time limit with a trade-off of trusting the hub - TODO: check this]

Counterfactual
- thinks about counterfactual instantiation
- also app instance on top, which we collaborated on
- possible to do meta-channels, but the details are not given in the paper and are still being finalized

ForceMove

Our contribution:
- like perun without the time limit
Unconstrained subchannels

\section{State Channel Background}

In this paper, we are focus on the construction of networks of state channels, which we treat separately from the operation of those channels.
For the purpose of this work, we view a state channel and its states purely as a device for enabling a given party to realize a given outcome on-chain, in a sense that we will make precise.
In particular, we do not specify the state format, the update rules, the mechanics of on-chain challenges or how to respond to them.

The ForceMove framework is an example of a state channel framework that specifies all these details. 
The state channel networks presented here were designed to work with ForceMove and we will frequently present examples involving ForceMove channels.
That said, the techniques provided here should be applicable to any state channel framework sharing the features presented in this section.

We start the section by reviewing the properties of ForceMove that are important for Turbo and Nitro \footnote{We give a more complete recap of ForceMove in the appendix.}. 
We then introduce some concepts that will be useful later when reasoning about the correctness of our state channel networks. 

\subsection{Participants, Addresses and Assets}

A ForceMove state channel belongs to a set of \textbf{participants}, each defined by a unique cryptographic address.
The private keys corresponding to these addresses are used to sign updates to the channel.
We assume that the signature scheme is unforgeable, so that only the owner of the address has the capability to sign states as that participant.

Each channel has a \textbf{channel address} which is formed by taking the hash of the participant addresses along with a nonce, $k$, that is chosen by the participants in order to distinguish their channels from one another.
We assume that the hashing algorithm is cryptographically secure, so that it impossible for two different sets of participants to create a channel with the same address.
We also assume that the signature scheme and hashing algorithm together make it impossible to create a channel address that is the same as a participant address.
In practice, we accept that these statements will not be absolute but instead will hold with high probability.

A state channel ultimately determines the quantity of a given asset that each participant should receive.
The format that the asset quantity takes is an important consideration for a state channel.
Blockchains typically have a max integer size, $M$, meaning that a state channel on a single asset
has asset quantites in $\mathbb{Z}_M$, so that quantities above the max overflow.
Similarly the quantities for a state channel on two assets takes values in $\mathbb{Z}_M \times \mathbb{Z}_M$.
There are many other possibilities here, including having state channels on an arbitrary set of assets.
In this paper, we will simplify the explanation by only considering state channels on a single
asset, taking quantity values in $\mathbb{Z}$, thereby explicitly ignoring integer overflow issues.
We will refer to this asset as `coins'.

\subsection{Depositing, Holding and Withdrawing Coins}

In order to have value, a state channel system must be backed by assets held on-chain.
In our explanation, we assume that these funds are held and managed by a single smart contract,
which we will refer to as the \textbf{adjudicator}.
In practice, the adjudicator functionality and deposits could be split across multiple smart contracts.

We say that $\rchi$ \textbf{holds} $x$, in the case where there is a quantity of $x$ coins
locked on-chain against $\rchi$'s address.
We write this statement $\adj{\rchi\holds{x}}$, where the $\alpha$ denotes funds being held
and the $\adj{\quad}$ is used to indicate that the statement refers to state on the chain.
Note that in ForceMove, the only information stored on chain is the channel address and the quantity of the asset held for it - all other information resides in the off-chain states and is only visible on-chain in the case of a dispute.

The \textbf{deposit} operation, $D_\rchi(x)$, is an on-chain operation used to assign $x$ coins to channel $\chi$.
There are no restrictions on who can deposit coins into a channel - only that the
transaction must include a transfer of $x$ coins into the adjudicator.
\begin{align*}
D_\rchi(x) \adj{\rchi\holds{y}, } = \adj{\rchi\holds{x + y}}
\end{align*}

In order to distribute the coins it holds, a state channel, $\rchi$, must have one or more mechanisms for
registering its \textbf{outcome}, $\Omega_\rchi$, on-chain.
This registration must be done in a way that ensures that at most one outcome can be registered for each channel.
In ForceMove, outcomes are registered either via an unanswered challenge or by the presentation
of a \textit{conclusion proof} - a special set of states signed by participants indicating
that the channel has concluded, thus allowing them to skip the challenge timeout.
We write  $\adj{\Omega_\rchi}$ to represent the situation where the outcome $\Omega_\rchi$ for channel $\rchi$ has been registered on-chain.

Once an outcome is registered on-chain, it can be used to transfer coins between addresses,
through the application of one or more on-chain operations:
\begin{align*}
O \adj{\rchi\holds{a + b}, \Omega_\rchi} = \adj{A\holds{a}\rchi\holds{b}\Omega_\rchi'}
\end{align*}
The specification of the precise format for the outcome, $\Omega_\rchi$, and the operations, $O$,
will be given in the sections on Turbo and Nitro.
In the equation above, $A$ could be either a channel address or a participant address.

The \textbf{withdrawal} operation can be used to withdraw coins held at address $A$ by any
party with the knowledge of the corresponding private key. 
Note that the signature requirement coupled with the no-collision assumption means
it is only possible to withdraw from a participant address.
If $x \leq x'$ then
\begin{align*}
W_A(x) \adj{A\holds{x'}, } = \adj{A\holds{x'-x}}
\end{align*}
In practice the withdrawal should also specify the blockchain address where the funds should be sent.
A potential method signature is \texttt{withdraw(fromAddr, toAddr, amount, signature)}, 
where \texttt{signature} is $A$'s signature of the other parameters
\footnote{In practice, we can add the \texttt{senderAddress} to the parameters to sign,
in order to prevent replay attacks.}.

In practice, the operations $O$ and $W$ do not need to be separate blockchain transactions.
For example, in the ForceMove SimpleAdjudicator, funds are withdrawn directly using $\alpha_\chi$ and $\Omega_\chi$;
the intermediate state, $\alpha_A$, where funds are held against a participant address never exists on-chain.

\subsection{The Value of a State}\label{section:value-of-a-state}

The utility of a state channel comes from the ability to transfer the value
between participants without the need for an on-chain operation.
In order to reason about state channels, we therefore need to understand how this transfer
of value works.

The word `state' is very overloaded in the world of state channels.
In what follows we will need to distinguish between the state of an individual channel and
the entire state of all channels plus the adjudicator.
We will call the latter the \textbf{system state} and usually denote it with the symbol $\Sigma$.

We define the \textbf{value}, $\nu_A(\Sigma)$, of a system state $\Sigma$ for participant $A$,
to be the largest $x$ such that $A$ has an \textit{unbeatable strategy} to extract $x$
coins from the adjudicator, where by extract we mean to withdraw $x$ coins more than any we needed to deposit to execute the strategy.
The unbeatable strategy can involve signing (or refusing to sign) states off-chain, as well as
applying one or more on-chain operations.
The strategy might have to adapt based on the actions of other players but regardless of
the actions they take, it should still be possible for $A$ to extract $x$ coins.

In order to make the concept of an unbeatable strategy more tangible, we make the following assumptions about blockchain transactions:
\begin{enumerate}
  \item \textbf{Transactions are unimpeded}: given that the current time is $t$ and $\epsilon > 0$, then it is possible for any party to apply any operation, $O$, on-chain before time $t + \epsilon$.
  This assumption sidesteps issues of censorship, chain congestion and timing considerations around the creation of blocks.
  In practice, this assumption should be reasonable, provided that $\epsilon$ is sufficiently large.
  \item \textbf{Transactions \textit{can} be front-run}: given two parties, $p_1$ and $p_2$, and two operations, $O_1$ and $O_2$, there is no way for $p_1$ to ensure that they can apply $O_1$ to the chain before $p_2$ applies $O_2$.
  This assumption means that strategies that rely on executing a given transaction on-chain before someone else executes a different one are not allowed.
  \item \textbf{Transactions are free}: we ignore the cost of gas fees when calculating the value of a state.
  Modelling the effect of gas fees on state channel networks is an interesting and important area of research but falls beyond the scope of this paper.
\end{enumerate}

Although the main utility of state channels comes from transitions where the value changes,
in this paper we will be looking primarily at state transitions where the value of the system
remains the same.
We will use the fact that certain transitions preserve value for all participants, to allow us
to prove the correctness of operations involving the construction of state channel networks.

In particular, we will make use of the \textbf{principle of value equivalence}: if two system
states hold the same value for all participants, then we assume that all participants will
be willing to transition between them.
The one exception is any transition involving a deposit, where we assume that a participant depositing
$x$ coins into the system, will proceed if the value of the resulting state to them increases by $x$.

If we were considering transactions fees here, we would need to argue this principle more
carefully: with transaction fees, some of the transitions we see as value preserving here
would actually involve moving to a state of slightly lower value. 
We assume that the utility gained in being able to open and close channels off-chain overcomes
this issues in practice.

When analysing Turbo and Nitro, we will often need to calculate the value of a given system
state for a participant.
When doing this, it will be useful to break the strategies down into two stages: the strategy
for registering one or more outcomes on-chain, followed by the strategy for performing operations
on those outcomes on-chain.
We will focus on the former stage in the next section; the latter stage will be dealt with
separately in the sections for Turbo and Nitro.

\subsection{Finalizable and Enabled Outcomes}

In the previous section, we defined the value of a system in terms of an unbeatable strategy
for withdrawing a certain total.
In this section, we will focus on one part of this strategy: the ability to register a given
outcome in the adjudicator.

We say an outcome, $\Omega_\chi$, is \textbf{finalizable} for participant $A$, if $A$ has an unbeatable
strategy for registering this outcome in the adjudicator.
We use the notation $\enf{\Omega_\rchi}_A$, to represent a state of a channel, $\rchi$,
where the outcome, $\Omega_\rchi$, is finalizable by $A$.
\begin{align*}
  \enf{\Omega_\rchi}_A \xrightarrow{\text{A's unbeatable strategy}} \adj{\Omega_\rchi}
\end{align*}

It follows from the definition that exactly one of the following statements is true about
a channel $\rchi$ at any point in time:
\begin{enumerate}
  \item No participants apart from $p$ have a finalizable outcome.
        Participant $p$ has one or more finalizable outcome(s), $\Omega_\rchi^{(1)}, \dots, \Omega_\rchi^{(m)}$.
        We write this $\enf{\Omega_\rchi^{(1)} \dots \Omega_\rchi^{(m)}}_p$.
  \item There are at least two participants, $P = \{p_1, \dots, p_m \}$, who share the same
        finalizable outcome, $\Omega_\rchi$. We write this $\enf{\Omega_\rchi}_{p_1, \dots, p_m}$.
  \item There are no participants with any finalizable outcomes.
\end{enumerate}
The definition of finalizability excludes the case where two different finalizable outcomes are held
by different participants, as in this case at least one participant's strategy would be beatable
by the other participant's strategy.
We will see that all these possibilities naturally occur in sensible state channel protocols
except the last case, which usually means something has gone wrong.

\begin{example}
One example of when a finalizable outcome occurs is for the next mover in a ForceMove channel.
In ForceMove, participants take turns to sign states, so that in a channel with $n$ participants,
$p_i$ can only sign state $\sigma_m$ if $i = m \% n$.
If $p_i$ has just received $\sigma_{m-1}$, with \textit{current outcome}\footnote{The current outcome is stored as part of the state in ForceMove.} $\Omega_\rchi$, then $\Omega_\rchi$
is a finalizable outcome for $p_i$.
There are a couple of strategies here: one is to refuse to sign $\sigma_m$, trigger a force-move
on $\sigma_{m-1}$ and wait for the timeout. 
Another is to transition to transition to the conclude state, to allow a conclusion proof
to be created for $\omega$, so that the participants can avoid waiting for the timeout
\footnote{The fact that the first strategy exists is why ForceMove allows a transition to
conclude from any state, to allow participants to attempt the second strategy and save everyone some time}.
\end{example}

\begin{example}
A ForceMove channel with two different conclusion proofs are held by two different participants
is an example of a situation where there are no finalizable outcomes for any participant.
Each conclusion proof can be immediately finalized on-chain, with no opportunity for challenge.
Therefore, the first conclusion proof to be presented to the adjudicator wins. 
Due to our decision to allow front-running, there is no strategy that can ensure that one
conclusion proof will always hit the adjudicator first.
As discussed above, this is not a desireable situation.
This is the reason that participants should never sign two conclusion proofs
with different outcomes.
\end{example}

If a participant has no finalizable outcomes, their analysis of the system needs to be performed
in terms of their \textbf{enabled outcomes}.
The enabled outcomes for a participant, $p$, is defined as the set of outcomes that $p$ has
no strategy to prevent from being finalized.
We write the set of enabled outcomes for $p$ as $\enf{\Omega_\rchi^{(1)} \dots \Omega_\rchi^{(m)}}_{(p)}$.

For any participant, $p$, in a channel, $\rchi$, exactly one of the following statements is
true at a given point in time:
\begin{enumerate}
  \item $p$ has at least one finalizable outcome.
  \item $p$ has at least two enabled outcomes.
\end{enumerate}
Note that, due to the property that any participant can force an outcome within a finite time,
that if a participant has only enabled a single outcome, that outcome must be finalizable for them.

\begin{example}{}
  All ForceMove channels start with a setup phase of $2n$ states, where $n$ is the number of participants.
  During this phase, the framework transition rules prevent the current outcome, $\Omega_\rchi$, from changing.
  At the midpoint, when state $\sigma_n$ has just been broadcast, the outcome
  $\Omega_\rchi$ is finalizable for every participant, i.e. we have
  $\enf{\Omega_\rchi}_{p_1, \dots, p_n}$.
  The outcome $\Omega_\rchi$ is finalizable because, due to the special transition rules,
  it is the only outcome that each participant has enabled by the states they have signed so far.
  As we will see later, this property of a ForceMove channel is important when opening and
  closing channels.
\end{example}

We will finish this section on finalizable outcomes by talking about \textbf{universal finalizability}.
A state channel with participants $P = \{p_1, \dots, p_n\}$ is said to be in a universally finalizable
state if there is an outcome, $\Omega_\rchi$, that is finalizable for every participant, i.e.
$\enf{\Omega_\rchi}_{p_1,\dots, p_n}$.
We will sometimes write this state using the shortened notation $\enf{\Omega_\rchi}_P$.

We have already come across two important examples of times when a ForceMove state channel
gets into a universally finalizable state:
\begin{enumerate}
  \item After the first $n$ states have been broadcast. In this state, we say the channel is at the \textbf{funding point}.
  \item When a single conclusion proof exists. In this state, we say the channel is in the \textbf{concluded state}.
\end{enumerate}
It is an important property of ForceMove that all channels have one universally finalizable
state at the beginning of their lifecycle and one at the end
\footnote{If a channel does not end with a conclusion proof, it ends with an expired on-chain challenge,
in which case the outcome is already finalized on-chain.}.

\subsection{Value Preserving Consensus Transitions}

Another important example of universally finalizable states comes from the \textbf{consensus game}.
The consensus game is a ForceMove \textit{application}, which means it specifies a certain
set of transitions rules that can be used to define the allowed state transitions for a ForceMove
channel.
We give a complete definition of the consensus game in the appendix.

At a very high level, the consensus game provides a mechanism for moving from one universally
finalizable outcome, $\Omega_\rchi^{(1)}$, to another, $\Omega_\rchi^{(2)}$. 
In order for this to happen, one participant proposes the new outcome, $\Omega_\rchi^{(2)}$, and then
every other participant must sign off on it. 
If any participant disagrees, they can cancel the transition.
This process has the important property that throughout its operation no participant enables
any outcome other than $\Omega_\rchi^{(1)}$ and $\Omega_\rchi^{(2)}$.
We call this a \textbf{consensus transition} between the two outcomes.

In the presentation of Turbo and Nitro, we will often use the fact that, if you use the
consensus game transition to move between two system states with the same value to a
participant, then all the intermediate states also have the same value to that participant.
This is the key observation that allows us to prove that we can open and close channels
off-chain.

\textbf{Value Preserving Consensus Transitions (VPCTs)}:
If I have two system states, $\Sigma$ and $\Sigma'$, which only differ in the state of
a consensus game chanel, $\rchi$, with participants $P$ and universally enforceable outcomes
$\enf{\Omega_\rchi}_P \in \Sigma$ and $\enf{\Omega'_\rchi}_P \in \Sigma'$, and 
for some participant $p \in P$, $\nu_p(\Sigma) = \nu_p(\Sigma') = x$, then
applying a consensus game transition gives a sequence of system states 
$\Sigma = \Sigma_0, \dots, \Sigma_m = \Sigma'$ where $\nu_p(\Sigma_i) = x$ for all $\Sigma_i$.

Proof (sketch): As $\nu_p(\Sigma) = \nu_p(\Sigma) = x$ and $\Sigma$ and $\Sigma'$ only differ
in $\rchi$, we know that if $p$ can register either outcome $\Omega_\rchi$ or $\Omega'_\rchi$ on-chain, then
they can obtain value $x$. The consensus transition allows the participants to transition
from outcome $\Omega_\rchi$ to $\Omega'_\rchi$ without any participant enabling any other outcome.
Therefore at all points, $p$ is capable of registering one of those outcomes on-chain (though
in general they cannot choose which).
Therefore, at all points, the value of the system to $p$ is $x$.

\section{Turbo Protocol}

Turbo protocol allows a set of participants who already have a funded channel to open and
close sub-channels without any on-chain transactions. 
In order to do this, the protocol specifies the format of the channel outcomes and how
they are interpreted on-chain.
It does not specify the channel update and challenge mechanics but can be combined with
ForceMove to provide a fully functional system.

As an example of what Turbo enables, suppose Alice and Bob want to play a game of chess and that
they already have an existing state channel, $\rchi_L$.
The winner of the game of chess should receive 2 coins from the loser and $\rchi_L$ currently holds
5 of Alice's coins and 5 of Bob's.

\begin{center}
  \includegraphics[scale=0.5]{turbo_start} % TODO: tikz
\end{center}

Alice and Bob proceed by creating a new channel $\rchi_C$ for the chess game with the appropriate starting state.
They then update $\rchi_L$ to allocate funds to these games.

\begin{center}
  \includegraphics[scale=0.5]{turbo_open} %TODO: tikz
\end{center}

Once the funds are allocated, they are free to play the game of chess.
Updates to the chess channel are independent from updates to $\rchi_L$ and to
any other sub-channels that are potentially funded by it. 
Alice wins the chess game, so the final state in the chess channel allocates all the
funds to her.

\begin{center}
  \includegraphics[scale=0.5]{turbo_close} %TODO: tikz
\end{center}

To close the chess channel off-chain, Alice and Bob update the state of the ledger channel to absorb the outcome of the game.

\begin{center}
  \includegraphics[scale=0.5]{turbo_finish} %TODO: tikz
\end{center}

In the rest of this section we will present the protocol that makes the above interaction
possible.

\subsection{Turbo Outcomes and Operations}

Turbo protocol specifies the format of channel outcomes and the operations that
manipulate them once they are on-chain.
The process of registering the outcome with the chain is not specified, but could be accomplished
using the ForceMove protocol.

The outcome of a Turbo channel is an \textbf{allocation} of the channel's funds to other addresses.
These allocations take the form of an ordered list of address-value pairs.
To write allocations we will use the notation $(a_1{:}v_1, \dots, a_n{:}v_n)$, where the $a_i$
represent addresses and the $v_i$ represent values.
The key idea behind Turbo is that the addresses in the allocations are not limited to being
participant addresses but that they can also be addresses of other \textit{channels}.

The ordering in the allocation is significant and is used to determine a priority order for payouts,
which becomes important if channel does not hold enough funds to cover the entire allocation.

The naive algorithm for distributing the funds is to work along the allocation from the front,
paying funds out to the corresponding address until no funds are remaining.
In practice, we avoid introducing a dependency on the order of the payouts by using
the \textbf{overlap} function $\texttt{overlap}(p, \omega, x)$, which returns the payout owed
to $p$ from outcome $\omega$ when the channel is funded with $x$.
If we have $\adj{\beta_\rchi(\omega)}$ and $\texttt{overlap}(p, \omega, x) = y$, we say that $\rchi$ \textbf{allocates} $y$ to $p$ \textbf{within} $x$.
A python implementation of $\texttt{overlap}$ is given in the appendix.

\begin{align*}
  \texttt{overlap}(p, (), x) &= 0 \\
  \texttt{overlap}(p, \omega, 0) &= 0 \\
  \texttt{overlap}(p, (a:v, \omega), x) &=
  \begin{cases}
    \texttt{min}(v, x) & \text{if } a = p \\
    \texttt{overlap}(p, \omega, \texttt{max}(x - v, 0)) & \text{otherwise}
  \end{cases}
\end{align*}

\begin{figure}[ht]
  \centering
  \includegraphics[scale=0.7]{overlap} % TODO: tikz
  \includegraphics[scale=0.7]{remove} % TODO: tikz
  \caption{Overlap and remove}
\end{figure}

Once an allocation, $\omega$, has paid out a total, $x$, to an address, $A$, we will \textbf{remove} the total to create a new outcome $\omega' = \texttt{remove}(A, \omega, x)$.
The remove operation works through the outcome from the start, reducing the totals for $A$ until $x$ coins have been removed.
A python implementation of $\texttt{remove}$ is given in the appendix.

Armed with overlap and remove, we can now define the only on-chain operation added by Turbo.
The \textbf{transfer} operation, $T_{A,B}(x)$, is an instruction to transfer $x$ coins
currently held by $A$ to $B$, according to the outcome of $A$.

The operation can be described as follows:
if channel $A$ holds at least $a \geq x$ coins
and the outcome, $\beta_A(\omega)$, of $A$ allocates $x$ to $B$ within $a$,
then decrease the total held by $A$ by $x$ coins,
increase the total held by $B$ by $x$ coins
and replace the outcome with $\beta_A(\omega')$, where $\omega' = \texttt{remove}(B, \omega, x)$.
Otherwise, do nothing.
We provide a python implementation of transfer in the appendix.
By way of an example:
\begin{align*}
T_{A,B}(3) \adj{A\holds{10}, \beta_A(B: 3, C: 7)} = \adj{A\holds{7}B\holds{3}\beta_A(C: 7)}
\end{align*}

Combined with the deposit and withdrawal operations, the transfer operation gives us everything we need to create a system that supports ledger channels.

\subsection{Value Equivalence in Turbo}

In section \ref{section:value-of-a-state} we defined the value of a system state, $\nu_p(\Sigma)$, to be the to be the largest $x$ such that $p$ has an unbeatable strategy to extract $x$ coins from the adjudicator.
We then split this into two parts: the unbeatable strategy for registering an outcome with the adjudicator and the unbeatable strategy for calling on-chain operations to move the coins into $p$'s address.
We looked a lot at the former part, which gave us the concept of a finalizable state,
but have not yet covered the second part.
In this section, we will look at what it takes to have an unbeatable strategy for moving funds from one address to another in Turbo.

For Turbo it turns out that the rule is very simple: if $p$ has any strategy for withdrawing $x$ coins from the adjudicator, it is an unbeatable strategy.

The following observation about the transfer operation is the key portion of the proof:
if I have the operation $T_{A, B}(x)$, that causes a change to the on-chain state,
then we must have some outcome $\adj{\beta_A(\omega)}$, which means that $A$ is a channel address and therefore withdrawals from $A$ are impossible.
Therefore the only operations that can reduce the total held in $A$ are transfers of the form $T_{A, \rchi}(x)$ for addresses $\rchi$ that appear in $\omega$.
Due to the definition of the transfer operation, all operations of this form commute.
So no transfer operation inserted in front of $T_{A, \rchi}(x)$ can change its effect on the state.

\subsection{Ledger channels}

While this generalization allows for a variety of relationships between different channels,
we will focus here on a setup where a single parent channel funds one or more sub-channels
\footnote{Note that we allow the case where the sub-channels are themselves ledger channels.}.
Following the Perun paper, we will refer to this parent channel as a \textbf{ledger channel}.

All ledger channels in the following sections run the consensus game, so that we can use the value preserving consensus transition result.

\subsubsection{Opening a sub-channel}

In this section, we give the details of the sub-channel opening process that we touched on at the beginning of the Turbo chapter.
We assume we start in a position where we have a ledger channel $L$ between $A$ and $B$, which contains enough to fund a sub-channel, $\rchi$.
This sub-channel runs an arbitrary ForceMove application and starts the process at the funding point, giving the universally finalizable below.
We progress through the following system states:
\begin{align*}
  S_1 &= \adj{L\holds{(a+b)}},\; L\allocs{A:a, B:b}{A,B}\\
  S_2 &= \adj{L\holds{(a+b)}},\; L\allocs{A:a, B:b}{A,B},\;  \rchi\allocs{A: a', B: b'}{A,B} \\
  S_3 &= \adj{L\holds(a+b)},\; L\allocs{A: a-a', B: b-b', \rchi: x }{A,B},\; \rchi\allocs{A: a', B: b' }{A, B}
\end{align*}
where $x = a' + b'$.
For all of these states, we have $\nu_A(S_i) = a$ and $\nu_B(S_i) = b$.
As each system state only differs in the state of one channel, we can apply the VPCT result, to see that we can move between the system states whilst keeping the system value constant for both $A$ and $B$.
At the end of this process, the funding of the sub-channel is complete and the players can proceed with the non-value preserving interaction within it.

\subsubsection{Closing a sub-channel}

Closing a sub-channel is very similar to opening a sub-channel, involving the same states in the reverse order.
In this instance, the universally finalizable state in the sub-channel, $\rchi$, is
taken to come from a conclusion proof.
\begin{align*}
S_1 &= \adj{L\holds{x}},\; L\allocs{A: a, B: b, \rchi: a' + b'}{A, B}, \; \rchi\allocs{A: a', B: b'}{A, B} \\
S_2 &= \adj{L\holds{x}}, \; L\allocs{A: a + a', B: b + b'}{A, B}, \; \rchi\allocs{A: a', B: b'}{A, B} \\
S_3 &= \adj{L\holds{x}}, \; L\allocs{A: a + a', B: b + b'}{A, B}
\end{align*}
where $x = a + a' + b + b'$.
The analysis here is exactly the same as in the opening case, where $\nu_A(S_i) = a + a'$ and $\nu_B(S_i) = b + b'$.
We then apply the VPCT result to argue that we can transition between these states without changing the value for either player.

\subsubsection{Topping up a ledger channel}

Sometimes it is useful for one participant to be able to increase their total in a ledger channel without disturbing any sub-channels operating in it.
In the scenario below, $A$ and $B$ have a ledger channel, $L$, supporting a sub-channel, $\rchi$, whose state is not shown.
Participant $A$ wants to increase their balance in the channel by an amount $a'$, through an on-chain deposit.
The operation proceeds as follows:
\begin{align*}
S_1 &= \adj{L\holds{x}}, \; L\allocs{A: a, B: b, \rchi: c}{A, B} \\
S_2 &= \adj{L\holds{x}}, \; L\allocs{B: b, \rchi: c, A: a + a'}{A, B} \\
S_3 &= D_L(a')\adj{L\holds{x}}, \; L\allocs{B: b, \rchi: c, A: a + a'}{A, B} \\
    &= \adj{L\holds{x + a'}}, \; L\allocs{B: b, \rchi: c, A: a + a'}{A, B}
\end{align*}
Here we have $\nu_A(S_1) = \nu_A(S_2) = a + c_A$, $\nu_A(S_3) = a + a' + c_A$ and the value to $B$ stays constant at $b + c_B$ throughout, where $c_A$ and $c_B$ is the value attributable to $A$ and $B$, respectively, from the $\rchi$ sub-channel.
The operation starts by moving $A$'s entry to the end of the list.
It is then safe to increase the total to $a + a'$, using the priority order payout property and the fact that the channel is underfunded, to see that this has not changed the value to $A$.
In the next line, $A$ deposits $a'$, which causes the value to $A$ to increase by the same amount, as should happen.
At this point the channel is fully funded and the participants are free to reorder the entries of the outcome as they please.

\subsubsection{Partial checkout from a ledger channel}

A partial checkout is the opposite case to a top up: here $A$ wants to withdraw $a'$ coins from the ledger channel, without disturbing any sub-channels.
The approach here is different to topping up.
The general idea is to replace the ledger channel, $L$, with an equivalent ledger channel, $L'$, with $A$'s balance reduced and then switch the funding across.
For simplicity, we assume that we start with $\adj{A\holds{0}}$, so $A$ has no funds held on-chain at the beginning.
\begin{align*}
S_1 &= \adj{L\holds x}, \; L\allocs{B: b, A: a, \rchi: c}{A, B}  \\
S_2 &= \adj{L\holds x}, \; L\allocs{B: b, A: a, \rchi: c}{A, B}, \; L'\allocs{B: b, A: a - a', \rchi: c}{A, B} \\
S_3 &= \adj{L\holds x)}, \; L\allocs{L': x-a', A: a'}{A, B}, \; L'\allocs{B: b, A: a - a', \rchi: c}{A, B}\\
S_4 &= \adj{L\holds{x}\allocs{L': x-a, A: a'}{}}, \; L'\allocs{B: b, A: a - a', \rchi: c}{A, B}\\
S_5 &= \adj{{L'}\holds{x-a'}, A\holds{a'}}, \; L'\allocs{B: b, A: a - a', \rchi: c}{A, B}
\end{align*}
All these states have the same value for $A$ and $B$.
The first two transitions rely on the VPCT result.
The move from $S_3$ to $S_4$ involves registering the outcome of $L$ on-chain.
It is assumed here that the participants create a conclusion proof, so that they can
skip the timeout.
The final transition involves applying the transfer operations $T_{L, L'}(x-a')$ and $T_{L, A}(a')$.

\section{Nitro Protocol}

Nitro Protocol is an extension to Turbo that introduces a new type of outcome and the on-chain operations to support it. 
We will show how this extension enables a channel between two participants to be supported through a third party.
Following the terminology in the Perun paper, we will refer to these channels as \textbf{virtual channels}.

As an example, suppose that Alice wants to open an $\{A:5, B:5\}$ chess game with Bob, but they do not share an existing ledger channel.
Alice does, however, have an $\{A:5, C:5\}$ ledger channel open with Carol and Bob and Carol have a $\{B:5, C:5\}$ ledger channel open too.

Nitro Protocol allows Alice and Bob to open their chess game, using their existing ledger channels with Carol, without the need for any on-chain transactions.
Suppose that Alice wins all of the funds in the channel, so that the final outcome is $\{A: 10, B: 0\}$.
Then Nitro allows Alice and Bob to close their chess game off-chain too, rebalancing through Carol, so that the final state of the ledger channels is $\{A: 10, C: 0\}$ and $\{B: 0, C: 10\}$.

In this interaction, Carol contributed 10 of her coins at the beginning, which had to remain locked while Alice and Bob were playing.
She got those 10 coins back but they were distributed differently between the her ledger channels.
By locking up her coins for a period of time, she enabled Alice and Bob to play chess entirely off-chain.

In this section, we will introduce the new outcomes and operations, along with the network construction to make interactions like the above possible.

\subsection{Nitro Outcomes and Operations}

Nitro extends Turbo by adding \textbf{guarantor channels} a new type of channel with a new type of outcome.
The outcome of a guarantor channel - a \textbf{guarantee} - is used to change the preference order of an existing allocation.
For example, the guarantee $G\guars{\rchi}{B}{}$ means that guarantee channel $G$ pays out according to the outcome of allocation channel $\rchi$, but with $B$ pulled to the front of the list of priorities:
\begin{align*}
\adj{G\holds 3 \guars{\rchi}{B}{}, \rchi\allocs{A: 3, B: 3}{}} \Rightarrow \adj{B \holds 3, \rchi\allocs{A: 3}{}}
\end{align*}
If more than one address is specified in the guarantee, then all addresses are pulled to the front in the specified order. For example, $G\guars{\rchi}{B, A}{}$ pays out according to the outcome, $\omega$, of $\rchi$: first to $B$, then to $A$, and then to any remaining addresses in the order specified in $\omega$.

- nitro channels change the order of precedence of an allocation

- outcome is a guarantee instead of an allocation

- of the outcome

Along with the new type of channel, Nitro adds one operation: the \textbf{claim} operation, $G_{A, B, C}(x)$, which is used to claim on the guarantee of $A$ on $B$'s payout to $C$.

\subsection{Value Calculations}

- not as simple as turbo
- the following example shows you it is possible to have a strategy that is beatable
- say I am D and then I can withdraw 5 by doing:
\begin{multline*}
  T_{B, D}(5)G_{A, B, C}(5)\adj{A\holds{5}, B\holds{5}\gamma_{A, B}(C: 5)\beta_B(C: 5, D: 5)}\\= \adj{C\holds{5}, D\holds{5}}
\end{multline*}
- but only if no-one calls $T_{B, C}$ first
\begin{multline*}
  T_{B, C}(5)\adj{A\holds{5}, B\holds{5}\gamma_{A, B}(C: 5)\beta_B(C: 5, D: 5)} \\= \adj{C\holds{5}, A\holds{5}\gamma_{A, B}(C: 5)\beta_B(D: 5)}
\end{multline*}

- a bit contrived, unusual to have both guarantees on channels which hold their own funds

- a few observations:
  - new deposits cannot decrease the value for anyone
  - withdrawals only decrease the value for the withdrawer (relies on lack of overlap between participants and channels)
  - we only need to consider deposits and guarantees
  - seems generally not useful to have a guarantee on a channel which holds its own funds by design
    (and new deposits are dealt with above)
  - so we only need to consider guarantors on the same channel
  - consider two cases: completely overlapping, disjoint (ish) and summming

  - look at two special cases

\subsection{Virtual Channels}

- outline how we can use guarantee channels to create virtual channels
- the construction we will use is as follows


\input{figures/virtual-channels}

- worth thinking about how this works
- offload
- key is the joint A-B-C channel, source of truth for state of channel


\subsubsection{Opening a Virtual Channel}

Want to start in the situation where channels A-C and B-C exist and demonstrate how to
open the virtual channel situation

- first create the subchannel we want to fund
- and the joint channel and guarantee channels to support it
everything here is disconnected
- then we update the ledger channels, one at a time to fund the guarantees
- finally we update the joint channel to fund the virtual channel

\subsubsection{Closing a Virtual Channel}

Opening a channel in reverse
- start with the virtual channel coming to a finalizable outcome e.g. conclude
- then A or B propose an update to j
- once A and B have signed off, it's in C's interest too
- then they can defund the guarantee channels independently


\section{Acknowledgements}

- Andrew Stewart
- James Prestwich
- Chris Buckland
- Magmo team


\section{Appendix}

\subsection{Overview of ForceMove}
\subsection{The Consensus Game}
\subsection{Virtual Channels on Turbo}
\subsection{Payouts to Non-Participants}
\subsection{Possible Extensions}

\subsection{On-chain Operations Code}
\subsubsection{Overlap}
\begin{minipage}{\linewidth} % minipage to avoid page breaks
  \lstinputlisting[language=Python]{code/overlap.py}
\end{minipage}

\subsubsection{Remove}
\begin{minipage}{\linewidth} % minipage to avoid page breaks
  \lstinputlisting[language=Python]{code/remove.py}
\end{minipage}

\subsubsection{Transfer}
\begin{minipage}{\linewidth} % minipage to avoid page breaks
  \lstinputlisting[language=Python]{code/transfer.py}
\end{minipage}

\subsubsection{Claim}\label{appendix:claim}
\begin{minipage}{\linewidth} % minipage to avoid page breaks
  \lstinputlisting[language=Python]{code/claim.py}
\end{minipage}

\end{document}
