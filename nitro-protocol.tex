\section{Nitro Protocol}

Nitro protocol is an extension to Turbo protocol.
In Nitro protocol, the outcome of a channel can be either an allocation or a \textbf{guarantee}.
There are two on-chain redistribution operations: the transfer and the \textbf{claim}.

Nitro enables true state channel networks with virtual channels, where channels are routed through intermediaries.
In particular, the extra features of Nitro allow virtual channels to be safely opened and closed off-chain while maintaining the property that channels update independently\footnote{It is possible to implement virtual channels in Turbo but only by breaking the independent update constraint. We believe this constraint will be important when running large scale state channel networks.}.

\subsection{Guarantees and Claims}

- guarantees are paired with allocations
- for a guarantee outcome to pay out funds, it needs to ba paired with a allocation outcome
- target a given outcome 
- allows them to pay out in a different priority

- complicated in that we may not know the precise outcome or even the addresses that will appear in it at the time we create the guarantee
- because of this we need to record the guarantee to apply a range of outcomes
- use the format of a list of addresses, that will be moved to top priority

- if guarantee specifies [a, b, c] and the outcome is (c: 1, d:2, a:4), then the guarantee will pay out as though the outcome was (a:4, c:1, d: 2)

- can afford

\begin{tikzpicture}[y=0.8cm]
  \node[semicircle, draw] (upper) at (0,0) {};
  \node[semicircle, draw, rotate=180] (lower) at (0,-1) {};

  \draw[-] (upper.220) to (lower.320);
  \draw[-] (upper.270) to (lower.270);
  \draw[-] (upper.320) to (lower.220);

  \node[semicircle, draw] (upper1) at (1,0) {};
  \node[semicircle, draw, rotate=180] (lower1) at (1,-1) {};

  \draw[-] (upper1.220) to[out=270, in=90] (lower1.270);
  \draw[-] (upper1.270) to[out=270, in=90] (lower1.220);
  \draw[-] (upper1.320) to[out=270, in=90] (lower1.320);

  \pic (A) at (2, -0.5) {guarantee};
\end{tikzpicture}

\begin{figure}[ht]\centering
  \makebox[\textwidth][c]{\input{figures/claim-operation}}
  \caption{The claim operation}
  \label{fig:claim-operation}
\end{figure}

Nitro adds the \textbf{claim} operation, $\claim{G}{A}{x}$, to the existing transfer, deposit and withdraw operations.
If $G$ acts as guarantor for $L$ and can afford $x$ for $A$, then $\claim{G}{A}{x}$ has the following three effects:
\begin{itemize}
  \item Reduces the funds held in channel $G$ by $x$.
  \item Increases the funds held in channel $A$ by $x$.
  \item Reduces the amount owed to $A$ in the outcome of $L$ by $x$.
\end{itemize}
Otherwise, the claim operation has no effect.


\subsection{Redistributing}

Reasoning about redistribution in Nitro is more complicated than in Turbo.
For a start, it is possible to construct situations where the same outcome can lead to different values, depending on the order in which guarantees are claimed.
Figure \ref{fig:claim-redistribution-problem} shows one of these situations.
\begin{figure}[ht]\centering
  \makebox[\textwidth][c]{\input{figures/claim-redistribution-problem}}
  \caption{
    Guarantee claim ordering problem.
    In the diagram both $G_1$ and $G_2$ guarantee $J$'s outcome with $I$ as first priority but with different second priorities.
    If $G_1$ is claimed first, then when $G_2$ is claimed the funds go to $B$.
    If $G_2$ is claimed first, then when $G_1$ is claimed the funds go to $A$.
    Whether $A$ or $B$ ultimately gets paid depends on the order that the guarantees are claimed.
  }
  \label{fig:claim-redistribution-problem}
\end{figure}

Despite this issue, it is still possible to make some statements about redistribution in Nitro, in particular putting some lower bounds on how funds are distributed.
For example, in the example in figure \ref{fig:claim-redistribution-problem} one thing we can definitely say is that participant $I$ will receive their 5 coins, even though we cannot say anything about how the remaining 5 coins will be distributed between $A$ and $B$.
These lower bounds prove to be enough to handle the constructions used in the rest of the chapter.

We can calculate this lower bound with a modification the Turbo Value Algorithm.
The key idea is when handling outcomes that are targets of one or more guarantees, to perform a separate analysis 


\textbf{Minimum Payout Calculation}



In this calculation we will consider an allocation channel, $L$, whose outcome allocates $a_1 \dots a_m$ to destination addresses $D_1 \dots D_m$, and a set of guarantees $G_1 \dots G_n$ which target $L$.
We want to calculate the minimum payout, $p_i$, that each destination will receive when all possible payout orders are considered.

Each guarantee, $G_i$, induces a permutation $\pi_i$ on the destination addresses, so that $G_i$ prioritizes the outcomes in the order $D_{\pi_i(1)} \dots D_{\pi_i(m)}$.

We start in a state where the values of channel $L$ and the guarantees are known, with $G_i$ having value $v_i = \texttt{Value}[G_i]$.
We will assume the value of $L$ itself is 0. 
We are free to do this because, if $\texttt{Value}[L] = x > 0$, then for the purpose of running the algorithm we can write the problem in an equivalent way, by adding a guarantee $G_{n+1}$ that has value $x$, that targets $L$ and that has $\pi_{n+1}(k) = k$.

If $\sum v_i > \sum a_j$, then we say the system is overfunded. 
In this case, we know that all destinations will receive their allocations, so $p_i = a_i$ regardless of the order of payout.
Otherwise, we let $p_{ij} > 0$ be the amount paid out from guarantee $G_i$ to destination $D_j$ and introduce the following set of constraints to ensure that we only consider situations where no funds are left in the guarantees:
\begin{equation}
  \sum_{j} p_{ij} = v_i
\end{equation}

It is useful to introduce the deficit, $\delta_j > 0$, for the destination $D_j$, defined by the equations:
\begin{equation}
  \delta_j + \sum_{i} p_{ij} = a_j
\end{equation}

Finally we can write down the a set of constraints that encode the priority order of the guarantees:
\begin{align}
\begin{split}
  p_{i\pi_j(2)} > 0 &\Rightarrow \delta_{\pi_j(1)} = 0 \\
  p_{i\pi_j(3)} > 0 &\Rightarrow \delta_{\pi_j(2)} = \delta_{\pi_j(1)}  = 0 \\
  &\vdots \\
  p_{i\pi_j(m)} > 0 &\Rightarrow \delta_{\pi_j(m-1)} = \dots = \delta_{\pi_j(1)}  = 0 
\end{split}
\end{align}

We can then calculate $p_i = a_i - \delta_i^*$, where $\delta^*_i$ is found by minimising $\delta_i$ subject to these constraints.

In general, calculating the minimimum payout therefore involves solving a constrained optimization problem, with non-linear constraints.
In practice, for all the calculations required for the constructions in this paper, it is sufficient to look at two special cases: (i) when the allocation is fully funded and (ii) when there is only a single guarantee.
In the fully funded case, where $\sum v_i = \sum a_i$, it is easy to see that $p_i = a_i$, just as in the overfunded case.
In the single guarantee case, the payouts are fully determined, so it is easy to calculate the minimum payout.


- in general this is a non-linear optimization
- suffice to look at two special cases: fully funded and single guarantee

Example
\begin{equation}
\adj{\holds{G_1}{5}{\guar{J}{I, A, B}},\; \holds{G_2}{5}{\guar{J}{I, B, A}}, \; \holds{J}{}{\alloc{I: 5, A: 5, B: 5}}}
\end{equation}

Let $D_1 = I$, $D_2 = A$, $D_3 = B$.

\begin{align}
  \delta_1 + p_{11} + p_{21} &= 5 \label{eq:delta1} \\
  \delta_2 + p_{12} + p_{22} &= 5 \label{eq:delta2} \\
  \delta_3 + p_{13} + p_{23} &= 5 \label{eq:delta3}
\end{align}

\begin{align}
  p_{11} + p_{12} + p_{13} &= 5 \label{eq:g1} \\
  p_{21} + p_{22} + p_{23} &= 5 \label{eq:g2}
\end{align}

\begin{align}
  p_{12} > 0 &\Rightarrow \delta_1 = 0 \label{eq:p12} \\
  p_{13} > 0 &\Rightarrow \delta_2 = \delta_1 = 0 \label{eq:p13} \\
  p_{23} > 0 &\Rightarrow \delta_1 = 0 \label{eq:p23} \\
  p_{22} > 0 &\Rightarrow \delta_3 = \delta_1 = 0 \label{eq:p22}
\end{align}

First suppose that $\delta_1 > 0$.
Then equations (\ref{eq:p12}) to (\ref{eq:p22}) give that $p_{12} = p_{13} = p_{23} = p_{22} = 0$.
Substituting into equation (\ref{eq:g1}) gives that $p_{11} = 5$ and, similarly, equation (\ref{eq:g2}) gives that $p_{21} = 5$.
But then equation (\ref{eq:delta1}) cannot possibly hold.
So $\delta_1 = 0$ in all cases and therefore $\delta_1^* = 0$.

- key insight is to form groups comprising of a ledger channel plus all the guarantees that target the ledger channel
- we then use a different rule to 


- suffices to get lower bound 
- follow the same algorithm as before but with guarantees treated as units
- calculate the minimum that comes out to each downstream address

\subsection{Virtual Channels}

A virtual channel is a channel between two participants who do not have a shared on-chain deposit, supported through an intermediary.
We will now give the construction for the simplest possible virtual channel, between $A$ and $B$ through a shared intermediary, $I$.
Our starting point for this channel is a pair of ledger channels, $L$ and $L'$, with participants $\{A,I\}$ and $\{B,I\}$ respectively.
\begin{align}
  \adj{\holds{L}{x}{}, \holds{L'}{x}{}}, \; \finalizable{L}{\alloc{A:a, I:b}}{A, I}, \; \finalizable{L'}{\alloc{B: b, I: a}}{B, I} \label{eq:virtual-channel-start-state}
\end{align}
where $x = a + b$.
The participants want to use the existing deposits and ledger channels to fund a virtual channel, $\rchi$, with $x$ coins.

In order to do this the participants will need three additional channels: a joint allocation channel, $J$, with participants $\{A, B, I\}$ and two guarantor channels $G$ and $G'$ which target $J$. The setup is shown in figure \ref{fig:virtual-channel-construction}.

\begin{figure}[ht]
  \centering
  \input{figures/virtual-channels-construction}
  \caption{Virtual channel construction}
  \label{fig:virtual-channel-construction}
\end{figure}

We will cover the steps for safely setting up this construction in section \ref{section:open-close-virtual-channel}. 
In the next section, we will explain why this construction can be considered to fund the channel $\rchi$.

\subsection{Offloading Virtual Channels}

Similarly to the method for ledger channel construction, we will show that the virtual channel construction funds $\rchi$ by demonstrating how any one of the participants can offload the channel $\rchi$, thereby converting it to an on-chain channel that holds its own funds.

We will first consider the case where $A$ wishes to offload $\rchi$. $A$ proceeds as follows:
\begin{enumerate}
  \item $A$ starts by finalizing all their finalizable outcomes on-chain:
  \begin{align}
    \adj{\holds{L}{x}{\alloc{G:x}}, \; \holds{L'}{x}{}, \holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{align}
  Although $A$ has the power to finalize $L$, $G$ and $J$, they are not able to finalize $L'$.
  Thankfully, this does not prevent them from offloading $\rchi$.
  \item $A$ then calls $\transfer{L}{G}{x}$ to move the funds from $L$ to $G$:
  \begin{align}
    \adj{\holds{L'}{x}{}, \holds{G}{x}{\guar{J}{\rchi, A, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{align}
  \item Finally $A$ calls $\claim{G}{A}{\rchi}$ to move the funds from $G$ to $\rchi$.
  \begin{align}
    \adj{\holds{L'}{x}{}, \holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{J}{}{\alloc{I: x}}, \; \holds{\rchi}{x}{}}
  \end{align}
\end{enumerate}
As $G$ has $\rchi$ as top priority, the operation is successful.

By symmetry, the previous case also covers the case where $B$ wants to offload.
The final case to consider is the one where $I$ wants to offload the channel and reclaim their funds.
This is important to ensure that $A$ and $B$ cannot lock $I$'s funds indefinitely in the channel.
\begin{enumerate}
  \item $I$ starts by finalizing all their finalizable outcomes on-chain:
  \begin{multline}
    \adj{\holds{L}{x}{\alloc{G:x}}, \; \holds{L'}{x}{\alloc{G':x}}, \holds{G}{}{\guar{J}{\rchi, A, I}}, \; \\\holds{G'}{}{\guar{J}{\rchi, B, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{multline}
  \item $I$ then transfers funds from the ledger channels to the virtual channels by calling $\transfer{L}{G}{x}$ and $\transfer{L'}{G'}{x}$:
  \begin{align}
    \adj{\holds{G}{x}{\guar{J}{\rchi, A, I}}, \; \holds{G'}{x}{\guar{J}{\rchi, B, I}}, \; \holds{J}{}{\alloc{\rchi: x, I: x}}}
  \end{align}
  \item Then $I$ claims on one of the guarantees, e.g. $\claim{G}{\rchi}{x}$ to offload $\rchi$:
  \begin{align}
    \adj{\holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{G'}{x}{\guar{J}{\rchi, B, I}}, \; \holds{J}{}{\alloc{I: x}}, \; \holds{\rchi}{x}{}}
  \end{align}
  \item After which, $I$ can recover their funds by claiming on the other guarantee, $\claim{G'}{I}{x}$:
  \begin{align}
    \adj{\holds{G}{}{\guar{J}{\rchi, A, I}}, \; \holds{G'}{}{\guar{J}{\rchi, B, I}}, \;  \holds{\rchi}{x}{}, \; \holds{I}{x}{}}
  \end{align}
\end{enumerate}
Note that $I$ has to claim on both guarantees, offloading $\rchi$ before being able to reclaim their funds.
The virtual channel became a direct channel and the intermediary was able to recover their collateral.

\subsection{Opening and Closing Virtual Channels}\label{section:open-close-virtual-channel}

\begin{figure}[ht] \centering
  \makebox[\textwidth][c]{\input{figures/opening-virtual-channel}}
  \caption{Opening a virtual channel}
  \label{fig:virtual-channel-opening}
\end{figure}

In this section we present a sequence of network states written in terms of universally finalizable outcomes, where each state differs from the previous state only in one channel.
We claim that this sequence of states can be used to derive a safe procedure for opening a virtual channel, where the value of the network remains unchanged throughout for all participants involved.
We justify this claim in the appendix.

The procedure for opening a virtual channel is as follows:
\begin{enumerate}
  \item Start in the state given in equation (\ref{eq:virtual-channel-start-state}):
  \begin{align}
    & \adj{\holds{L}{x}{}, \holds{L'}{x}{}}\\
    & \finalizable{L}{\alloc{A:a, I:b}}{A, I} \\
    & \finalizable{L'}{\alloc{B: b, I: a}}{B, I}
  \end{align}
  \item $A$ and $B$ bring their channel $\rchi$ to the funding point:
  \begin{align}
    \finalizable{\rchi}{\alloc{A:a, B:b}}{A,B}
  \end{align}
  \item In any order, $A$, $B$ and $I$ setup the virtual channel construction:
  \begin{align}
    & \finalizable{J}{\alloc{A:a, B:b, I: x}}{A, B, I} \\
    & \finalizable{G}{\guar{J}{\rchi, A, I}}{A, I} \\
    & \finalizable{G'}{\guar{J}{\rchi, B, I}}{B, I}
  \end{align}
  \item In either order switch the ledger channels over to fund the guarantees:
  \begin{align}
    & \finalizable{L}{\alloc{G: x}}{A,I} \\
    & \finalizable{L'}{\alloc{G': x}}{B,I}
  \end{align}
  \item Switch $J$ over to fund $\rchi$:
  \begin{align}
    \finalizable{J}{\alloc{\rchi: x, I: x}}{A, B, I}
  \end{align}
\end{enumerate}
We give a visual representation of this procedure in figure \ref{fig:virtual-channel-opening}.

\begin{figure}[ht]
  \centering
  \input{figures/virtual-channels-3}
  \caption{Opening a virtual channel}
  \label{fig:virtual-channel-opening}
\end{figure}


\begin{figure}[ht]\centering
  \makebox[\textwidth][c]{\input{figures/closing-virtual-channel}}
  \caption{Closing a virtual channel}
  \label{fig:virtual-channel-closing}
\end{figure}

The same sequence of states, when taken in reverse, can be used to close a virtual channel:
\begin{enumerate}
  \item Participants $A$ and $B$ finalize $\rchi$ by signing a conclusion proof:
  \begin{align}
    \finalizable{\rchi}{\alloc{A:a', B:b'}}{A,B}
  \end{align}
  \item $A$ and $B$ sign an update to $J$ to take account of the outcome of $\rchi$. $I$ will accept this update, provided that their allocation of $x$ coins remains the same:
  \begin{align}
    \finalizable{J}{\alloc{A: a', B:b', I: x}}{A, B, I}
  \end{align}
  \item In either order switch the ledger channels to absorb the outcome of $J$, defunding the guarantor channels in the process:
  \begin{align}
    & \finalizable{L}{\alloc{A: a', I: b'}}{A,I} \\
    & \finalizable{L'}{\alloc{B: b', I: a'}}{B,I}
  \end{align}
  \item The channels $\rchi$, $J$, $G$ and $G'$ are now all defunded, so can be discarded
\end{enumerate}

It is also possible to do top-ups and partial checkouts from a virtual channel.

\begin{figure}[ht] \centering
  \makebox[\textwidth][c]{\input{figures/virtual-channel-three-participants}}
  \caption{Virtual channel with three participants}
  \label{fig:virtual-channel-three-participants}
\end{figure}
